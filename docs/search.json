[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\n            Power, Politics, and Data\n        ",
    "section": "",
    "text": "Power, Politics, and Data\n        \n        \n            A Hands-On Introduction to Political Science Data Analysis with R.\n        \n        \n            Winter 2025Department of Government and PoliticsUniversity of Maryland, College Park\n        \n    \n    \n      \n        \n        \n        \n      \n    \n\n\n\n\n\n\nLecturer\n\n   Harriet Goers\n   Chincoteague Building\n   hgoers@umd.edu\n   hgoers\n\n\n\n\nCourse details\n\n   January 2 - 22\n   Asynchronous\n   Online\n\n\n\nOffice hours\n\n   By appointment\n   Zoom\n\n\n\n\nContacting me\nE-mail is the best ways to get in contact with me. I will try to respond to all course-related e-mails within 24 hours."
  },
  {
    "objectID": "content/03-02-bivariate.html",
    "href": "content/03-02-bivariate.html",
    "title": "Exploring the Relationship Between Two Variables",
    "section": "",
    "text": "To complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(c(\"countrycode\", \"broom\"))\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(wbstats)\nlibrary(poliscidata)\nlibrary(countrycode)\nlibrary(broom)\nlibrary(janitor)\nlibrary(ggridges)\nlibrary(modelsummary)\nlibrary(scales)",
    "crumbs": [
      "Content",
      "Session 3",
      "Exploring the Relationship Between Two Variables"
    ]
  },
  {
    "objectID": "content/03-02-bivariate.html#set-up",
    "href": "content/03-02-bivariate.html#set-up",
    "title": "Exploring the Relationship Between Two Variables",
    "section": "",
    "text": "To complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(c(\"countrycode\", \"broom\"))\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(wbstats)\nlibrary(poliscidata)\nlibrary(countrycode)\nlibrary(broom)\nlibrary(janitor)\nlibrary(ggridges)\nlibrary(modelsummary)\nlibrary(scales)",
    "crumbs": [
      "Content",
      "Session 3",
      "Exploring the Relationship Between Two Variables"
    ]
  },
  {
    "objectID": "content/03-02-bivariate.html#bivariate-relationships",
    "href": "content/03-02-bivariate.html#bivariate-relationships",
    "title": "Exploring the Relationship Between Two Variables",
    "section": "Bivariate relationships",
    "text": "Bivariate relationships\nHow do two variables move with one another? When when goes up, does the other go down, up, or not really move at all? How dramatic is this shift?\nThe type of variables we have determines how we can answer this question. To begin, we will explore the relationship between two continuous variables. Later in the section, we will look at how to explore the relationship between a continuous and categorical variable.\nWe will return to the relationship between a country’s wealth and health. This question was made popular by the Gapminder project. We were introduced to it during the Transformations section in Session One.\nCollecting our data\nFirst, we need to collect our data. Following the Gapminder project, we measure each country’s health by its average life expectancy and its wealth by its GDP per capita. We will use wbstats::wb_data() to pull these data directly from the World Bank.\n\ngapminder_df &lt;- wb_data(\n  indicator = c(\"SP.DYN.LE00.IN\", \"NY.GDP.PCAP.CD\"),\n  start_date = 2016,\n  end_date = 2016\n) |&gt; \n  # Give these variables more friendly names\n  rename(\n    life_exp = SP.DYN.LE00.IN,\n    gdp_per_cap = NY.GDP.PCAP.CD\n  ) |&gt;\n  mutate(\n    # Create a new variable that is GDP per capita logged\n    log_gdp_per_cap = log(gdp_per_cap),\n    # Add each country's region to the data set\n    region = countrycode(country, \"country.name\", \"region\")\n  ) |&gt; \n  relocate(region, .after = country)\n\ngapminder_df\n\n# A tibble: 217 × 8\n   iso2c iso3c country         region  date gdp_per_cap life_exp log_gdp_per_cap\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;\n 1 AW    ABW   Aruba           Latin…  2016      27442.     75.6           10.2 \n 2 AF    AFG   Afghanistan     South…  2016        522.     63.1            6.26\n 3 AO    AGO   Angola          Sub-S…  2016       1808.     61.1            7.50\n 4 AL    ALB   Albania         Europ…  2016       4124.     78.9            8.32\n 5 AD    AND   Andorra         Europ…  2016      40130.     NA             10.6 \n 6 AE    ARE   United Arab Em… Middl…  2016      41326.     79.3           10.6 \n 7 AR    ARG   Argentina       Latin…  2016      12700.     76.3            9.45\n 8 AM    ARM   Armenia         Europ…  2016       3524.     74.7            8.17\n 9 AS    ASM   American Samoa  East …  2016      12843.     NA              9.46\n10 AG    ATG   Antigua and Ba… Latin…  2016      16558.     78.2            9.71\n# ℹ 207 more rows\n\n\nWhat is the relationship between these two variables?\nWhat is the relationship between a country’s average life expectancy and its GDP per capita? The easiest way to determine this is to visualize these two variables:\n\nggplot(gapminder_df, aes(x = gdp_per_cap, y = life_exp)) + \n  geom_point() + \n  theme_minimal() + \n  labs(x = \"GDP per capita (USD current)\",\n       y = \"Average life expectancy (years)\") + \n  scale_x_continuous(labels = label_dollar())\n\n\n\n\n\n\n\nThere seems to be a good case that there is a strong relationship between a country’s GDP per capita (wealth) and its average life expectancy (health). It appears that we expect citizens that live in countries that have larger GPD per capita to live longer, on average. But this relationship is not linear (a straight line drawn through them will not summarize this relationship very well).\nBecause we want to explore linear relationships at this stage of the course, we will look at the logged GDP per capita variable:\n\nggplot(gapminder_df, aes(x = log_gdp_per_cap, y = life_exp)) + \n  geom_point() + \n  theme_minimal() + \n  labs(x = \"Logged GDP per capita\",\n       y = \"Average life expectancy (years)\") + \n  scale_x_continuous(labels = label_dollar())\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can transform your data to make it easier to work with. Just remember that you now need to talk in terms of logged GDP per capita instead of GDP per capita.\n\n\nI can imagine drawing a straight line among these points that summarizes how they vary with each other. It appears that as a country’s logged GDP per capita increases, so too does the average life expectancy of its population. As wealth increases, so too does health. These increases are consistent across each interval increase in wealth.\nWell, that was easy! What is the relationship between health and wealth? They increase with each other.\nHow can we measure the strength of that relationship?\nNow we need some way of measuring the strength of the relationship. In other words, what amount of the variation in countries’ average life expectancy is associated with variation in their GDP per capita? We can measure the strength of this association using correlations. The correlation coefficient tells us how closely variables relate to one another. It tells us both the strength and direction of the association.\n\nStrength: how closely are these values tied to one another. Measured from 0 to |1|, with values closer to 0 indicating a very weak relationship and values closer to |1| indicating a very strong relationship.\n\n\n\n\n\n\n\nTip\n\n\n\nWhat are those funny looking |s? They represent the absolute value, which is shorthand for the number regardless of its sign. To demonstrate, |1| is the absolute value of 1 and -1.\n\n\n\nDirection: do both \\(X\\) and \\(Y\\) change in the same direction? Positive correlations show that when \\(X\\) increases (decreases), so does \\(Y\\). Negative correlations show that when \\(X\\) increases (decreases), \\(Y\\) decreases (increases). In other words, they move in different directions.\n\nWhat is the correlation between logged GDP per capita and life expectancy?\n\ncor(gapminder_df$log_gdp_per_cap, gapminder_df$life_exp, use = \"complete.obs\")\n\n[1] 0.8506936\n\n\nAs expected, the relationship is positive and strong.\nBuilding a generalizable description of this relationship\nWe have very quickly gained the skills to determine whether the relationship between two variables is positive, negative, or non-existent. We have also learnt how to describe the strength of that relationship. To that end, we are now able to describe the bivariate relationship between health and wealth as a positive and strong one.\nThis is useful, but we tend to need a more concrete way of describing the relationship between two variables. For example, what if a policy-maker comes up to you and asks what you think the effect of a $1,000 increase in a country’s GDP per capita will do to its average life expectancy? We can build simple models of this relationship to provide that policy-maker with a prediction of what we might expect to happen, on average. Further, we can use the model to describe the relationship between these two variables in a generalized way. If a new country were to spring into existence, we can use our knowledge of its GDP per capita to determine how long we might expect its citizens to live.\nOLS and linear regression\nLooking back at our data, we can image a straight line running between each country’s plotted average life expectancy and GDP per capita. Let’s draw that line:\n\nggplot(gapminder_df, aes(x = log_gdp_per_cap, y = life_exp)) + \n  geom_point() + \n  theme_minimal() + \n  labs(x = \"Logged GDP per capita\",\n       y = \"Average life expectancy (years)\") + \n  scale_x_continuous(labels = label_dollar())\n\n\n\n\n\n\n\nWe can, of course, draw many different lines through these points. Each of us has probably drawn a slightly different line in our heads. Which is the best line?\nOrdinary least squares (OLS) regression provides an answer. OLS regression draws the line that minimizes the distance between itself and all of the data points. That line can take many shapes, including a straight line, an S, a frowney face, and smiley face, etc.\nLooking at our data above, it appears that a straight line is the best line to draw.\n\n\n\n\n\n\nNote\n\n\n\nOverfitting involves fitting a model (or drawing a line through our data) that misses the forest for the trees. You can draw all kinds of shapes through those data that perhaps result in a smaller distance between itself and each dot. In fact, if you draw a line that connects all of those dots there will be no difference between your line and the data points.\nHowever, this model will be too focused on the data we have at hand. Our model will have no idea what to do with any new data points we introduce. This is bad! Your aim here is to produce a generalizable model of the relationship between these two variables, not to draw a line that connects this particular constellation of dots.\n\n\nOkay, so a straight line is the best type of line to draw. But there are still many, many different straight lines that we can draw. Which straight line is best? Remember, OLS regression finds the line that minimizes the distance between itself and all of the data points. Let’s step through this. Look at the graph above.\n\nDraw a line through those dots. Pick a line, any line!\nCalculate the distance between each dot and the line.\nSum up the absolute values of those distances. Remember, we just care about the distance, so we don’t need to worry about whether or not the dots are above or below the line.\nRepeat steps 1 - 3 many, many, many times.\nPick the line with the smallest sum of distances (the results from step 3).\n\nPhew, this seems tedious. Happily, maths and R are to the rescue. Here is the line that minimizes those distances (all with the addition of one extra line of code).\n\nggplot(gapminder_df, aes(x = log_gdp_per_cap, y = life_exp)) + \n  geom_point() + \n  geom_smooth(method = \"lm\", se = F) + \n  theme_minimal() + \n  labs(x = \"Logged GDP per capita\",\n       y = \"Average life expectancy (years)\") + \n  scale_x_continuous(labels = label_dollar())\n\n\n\n\n\n\n\nEstimating a linear model in R\nHow did R do this? To answer this, we will first do some review.\nRemember (back to your high school maths classes) the general equation for a line:\n\\[\ny = a + mx\n\\]\nRead this as: the value of \\(y\\) is the sum of some constant, \\(a\\), and some \\(x\\) variable that has been transformed by some slope value \\(m\\).\nRemember that the slope constant, \\(m\\), tells you how much \\(y\\) changes for every one unit increase in \\(x\\).\nSo, if:\n\\[\ny = 10 + 2x\n\\]\nThen, when \\(x = 20\\):\n\\[\ny = 10 + 2*20 = 50\n\\]\nFor many values of \\(x\\):\n\nggplot(tibble(x = 0:50, y = 10 + 2*x), aes(x = x, y = y)) + \n  geom_line(colour = \"lightgrey\", linewidth = 3) + \n  geom_point() + \n  theme_minimal()\n\n\n\n\n\n\n\nWell, let’s substitute in our variables of interest. Our \\(y\\) variable is a country’s average life expectancy and our \\(x\\) variable is that country’s logged GDP per capita.\n\\[\nlife Exp_i = \\beta_0 + \\beta_1 logGdpPerCap_i + \\epsilon\n\\]\nRead this as: country \\(i\\)’s average life expectancy is a function of some constant (\\(\\beta_0\\)) and its logged GDP per capita transformed by some value \\(\\beta_1\\) with some random error (\\(\\epsilon\\)).\nLet’s imagine that this relationship is accurately described by the following formula:\n\\[\nlife Exp_i = 30 + 4 * logGdpPerCap_i\n\\]\n\n\n\n\n\n\nNote\n\n\n\nWe will get to that pesky error term in just a minute.\n\n\nThen, our model would predict the following average life expectancy for countries with log GDPs per capita between 0 and 20:\n\nggplot(\n  tibble(log_gdp_per_cap = 0:20, life_exp = 30 + 4*log_gdp_per_cap), \n  aes(x = log_gdp_per_cap, y = life_exp)\n) + \n  geom_line(colour = \"lightgrey\", linewidth = 3) + \n  geom_point() + \n  theme_minimal() + \n  labs(x = \"Logged GDP per capita\",\n       y = \"Average life expectancy (years)\") + \n  scale_x_continuous(labels = label_dollar())\n\n\n\n\n\n\n\nA country with a logged GDP per capita of 5 (the equivalent of a GDP per capita of $148.41) has a predicted average life expectancy of 50 years, or \\(30 + 4*5\\).\nA country with a logged GDP per capita of 10 (the equivalent of a GDP per capita of $22,026.47) has a predicted average life expectancy of 70 years, or \\(30 + 4*10\\).\nDoes this accurately describe what we see in our data? What is the average life expectancy for countries with roughly $22,000 GDP per capita?\n\ncountries_10 &lt;- filter(gapminder_df, gdp_per_cap &gt; 21000 & gdp_per_cap &lt; 23000)\n\ncountries_10\n\n# A tibble: 3 × 8\n  iso2c iso3c country          region  date gdp_per_cap life_exp log_gdp_per_cap\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;            &lt;chr&gt;  &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;\n1 KN    KNA   St. Kitts and N… Latin…  2016      21388.     71.7            9.97\n2 SA    SAU   Saudi Arabia     Middl…  2016      21516.     77.1            9.98\n3 SI    SVN   Slovenia         Europ…  2016      21448.     81.2            9.97\n\n\nWe predicted 70 years, but our data suggest that these countries have closer to an average of 77 years. Why do we have this difference?\nWell, we probably haven’t produced the best model we can (this isn’t the best line!). We just picked those numbers (\\(\\beta_0\\) and \\(\\beta_1\\)) out of thin air. Let’s fit a linear OLS regression and see if we improve our ability to predict what we have seen in the wild.\nHow do we calculate the constant (\\(\\beta_0\\)) using OLS regression?\nRemember, OLS regression simply finds the line that minimizes the distance between itself and all the data points.\n\n\n\n\n\n\nNote\n\n\n\nThe constant that minimizes this distance is the mean of \\(Y\\) minus \\(\\beta_1\\) times the mean of \\(X\\). You can prove this using some calculus. We won’t do that here, but feel free to Google it if you are very interested.\n\n\nSo, the constant that best predicts a country’s average life expectancy based on its logged GDP per capita is equal to the average life expectancy across our sample (72.3 years) minus the average logged GDP per capita ($8.80, or $6,652.93 GDP per capita) transformed by \\(\\beta_1\\).\nSo…\nHow do we calculate the coefficient \\(\\beta_1\\)?\nThe regression slope is the correlation coefficient between \\(X\\) and \\(Y\\) multiplied by the standard deviation of \\(Y\\) divided by the standard deviation of \\(X\\).\nEw… Let’s step through that.\nRemember, the correlation coefficient simply measures how \\(X\\) and \\(Y\\) change together. Does \\(Y\\) increase when \\(X\\) increases? How strong is this relationship?\nThe standard deviations of \\(X\\) and \\(Y\\) just measure how spread out they are.\nBringing these together, we are interested in how much \\(X\\) and \\(Y\\) change with each other moderated by how much they change independently of each other.\nFormally:\n\\[\n\\beta_1 = (\\frac{\\Sigma(\\frac{x_i - \\bar{x}}{s_X})(\\frac{y_i - \\bar{y}}{s_Y})}{n - 1})(\\frac{s_Y}{s_X}) = \\frac{\\Sigma(x_i - \\bar{x})(y_i - \\bar{y})}{\\Sigma(x_i - \\bar{x})^2}\n\\]\nHappily R does all of this for us.\nLet’s fit that model already!\n\nm &lt;- lm(life_exp ~ log_gdp_per_cap, data = gapminder_df)\n\nm\n\n\nCall:\nlm(formula = life_exp ~ log_gdp_per_cap, data = gapminder_df)\n\nCoefficients:\n    (Intercept)  log_gdp_per_cap  \n         32.794            4.521  \n\n\nOkay, so the line of best fit describing the relationship between average life expectancy and logged GDP per capita is:\n\\[\nlife Exp_i = 32.9 + 4.5 * logGdpPerCap_i + \\epsilon\n\\]\nThat’s it! We now have a model of the relationship between a country’s average life expectancy and its logged GDP per capita. This model is informed by what we actually observed in the world. It carefully balances our need to accurately describe what we have observed and to develop something that is generalizable.\nThe above model output is difficult to read. It will not be accepted by any journal or professor. Luckily, we can use modelsummary::modelsummary() to easily generate a professionally formatted table.\n\nmodelsummary(\n  m, \n  statistic = NULL,\n  coef_rename = c(\"log_gdp_per_cap\" = \"GDP per capita (logged)\"),\n  gof_map = \"nobs\"\n)\n\n\n\n    \n\n      \n\n \n                (1)\n              \n\n\n(Intercept)            \n                  32.794\n                \n\nGDP per capita (logged)\n                  4.521 \n                \n\nNum.Obs.               \n                  203   \n                \n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAlways make sure to change your variable names from ones that are easily read by a computer (for example, log_gdp_per_cap to one that are easily read by your human reader (for example, GDP per capita (logged)).\n\n\nAssumptions\nNote that OLS regression, particularly linear regression, requires that you make a lot of important assumptions about the relationship between your two variables. For example, we need to assume that the best line to fit is a straight one. We also assume that the best way to generate and describe the relationship across all observations is to fit the line that minimizes the distance between itself and the observed values or dots.\nThere are other approaches to determining the “best” line. These include maximum likelihood estimation and Bayesian statistics. We won’t discuss these approaches in this class. It’s worth noting here; however, that OLS regression requires a whole bunch of assumptions that may or may not be appropriate to your research question or theory. This class prepares you to grapple with those questions and to appropriately use these tools in your own research.\nPrediction and performance\nOkay, so we now have a model that describes the relationship between our outcome of interest (health) and our independent variable of interest (wealth). We can use this to predict our outcome of interest for different values of our independent variable. For example, what do we predict to be the average life expectancy of a country with a GDP per capita of $20,000?\nbroom::tidy(m) makes this model object a lot easier (tidier) to work with.\n\nm_res &lt;- tidy(m)\nm_res\n\n# A tibble: 2 × 5\n  term            estimate std.error statistic  p.value\n  &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)        32.8      1.75       18.8 4.18e-46\n2 log_gdp_per_cap     4.52     0.197      22.9 4.80e-58\n\n\nFirst, let’s pull out the estimated constant (or intercept or \\(\\beta_0\\)) for our calculations.\n\nbeta_0 &lt;- m_res |&gt; \n  filter(term == \"(Intercept)\") |&gt; \n  pull(estimate)\n\nbeta_0\n\n[1] 32.79384\n\n\nNext, let’s pull out the estimated coefficient for (logged) GDP per capita:\n\nbeta_1 &lt;- m_res |&gt; \n  filter(term == \"log_gdp_per_cap\") |&gt; \n  pull(estimate)\n\nbeta_1\n\n[1] 4.520601\n\n\nFinally, we can plug this in to our model:\n\\[\nlife Exp_i = \\beta_0 + \\beta_1 logGdpPerCap_i\n\\]\n\nlife_exp_20000 &lt;- beta_0 + beta_1 * log(20000)\nlife_exp_20000\n\n[1] 77.56355\n\n\nOn average, countries with GDPs per capita of $20,000 are predicted to have an average life expectancy of 78 years.\nLet’s take a look back at our data. Remember, these data describe what the World Bank actually observed for each country in 2016. How close is our predicted value to our observed values?\n\ncountries_10\n\n# A tibble: 3 × 8\n  iso2c iso3c country          region  date gdp_per_cap life_exp log_gdp_per_cap\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;            &lt;chr&gt;  &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;\n1 KN    KNA   St. Kitts and N… Latin…  2016      21388.     71.7            9.97\n2 SA    SAU   Saudi Arabia     Middl…  2016      21516.     77.1            9.98\n3 SI    SVN   Slovenia         Europ…  2016      21448.     81.2            9.97\n\n\nAs above, our data suggest that these countries have closer to an average of 77 years. Although our model predicted an average life expectancy closer to this than our guess above (which predicted 70 years), we still have a gap. Why?\nOur model is an attempt to formalize our understanding of the general relationship between a country’s wealth and health. Plotting our model against the observed values we used to generate it illustrates this point well:\n\nggplot(gapminder_df, aes(x = log_gdp_per_cap, y = life_exp)) + \n  geom_point() + \n  geom_vline(xintercept = log(20000)) + \n  geom_hline(yintercept = life_exp_20000) + \n  geom_smooth(method = \"lm\", se = F) + \n  theme_minimal() + \n  labs(x = \"Logged GDP per capita\",\n       y = \"Average life expectancy (years)\") + \n  scale_x_continuous(labels = label_dollar())\n\n\n\n\n\n\n\nThe world is a complicated and messy place. There are many countries that have a GDP per capita of around $20,000 (those dots sitting around the vertical black line). They have a wide range of average life expectancy: look at their various placement along that vertical line. Some are higher than others.\nAlso, there are several countries with a wide range of logged GDP per capita that have an average life expectancy of 78 years (those sitting at or around the horizontal black line). These have a wide range of logged GDP per capita: some are further to the left than others.\nOur model is our best attempt at accounting for that diversity whilst still producing a useful summary of the relationship between health and wealth for those countries and all other countries with all observed values of GDP per capita.\nA bit of noise (or error) is expected. How much error is okay? This is a complicated question that has contested answers. Let’s start with actually measuring that error. Then we can chat about whether or not it’s small enough to allow us to be confident in our model.\nMeasuring error in our model\nReturning to our question above, how close are our predicted values to our observed values? For example, how far from the observed average life expectancy of countries with a GDP per capita of or close to $20,000 is 78 years?\nStart by working out the average life expectancy predicted by our model for the logged GDP per capita of all of our countries. We can then compare this to the average life expectancy actually observed in all these countries. We can predict values from a model using broom::augment():\n\naugment(m)\n\n# A tibble: 203 × 9\n   .rownames life_exp log_gdp_per_cap .fitted .resid    .hat .sigma   .cooksd\n   &lt;chr&gt;        &lt;dbl&gt;           &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;\n 1 1             75.6           10.2     79.0 -3.38  0.00999   4.10 0.00347  \n 2 2             63.1            6.26    61.1  2.05  0.0192    4.10 0.00252  \n 3 3             61.1            7.50    66.7 -5.61  0.00850   4.08 0.00812  \n 4 4             78.9            8.32    70.4  8.43  0.00533   4.06 0.0114   \n 5 6             79.3           10.6     80.8 -1.51  0.0132    4.10 0.000921 \n 6 7             76.3            9.45    75.5  0.797 0.00609   4.10 0.000117 \n 7 8             74.7            8.17    69.7  4.95  0.00569   4.09 0.00421  \n 8 10            78.2            9.71    76.7  1.44  0.00712   4.10 0.000448 \n 9 11            82.4           10.8     81.7  0.753 0.0149    4.10 0.000260 \n10 12            81.6           10.7     81.2  0.406 0.0140    4.10 0.0000706\n# ℹ 193 more rows\n# ℹ 1 more variable: .std.resid &lt;dbl&gt;\n\n\nThis function is simply fitting our model (\\(life Exp_i = 32.9 + 4.5 * logGdpPerCap_i\\)) to each country’s logged GDP per capita. You can confirm this by running the model yourself:\n\ngapminder_df |&gt; \n  transmute(country, log_gdp_per_cap, .fitted = beta_0 + beta_1*log_gdp_per_cap)\n\n# A tibble: 217 × 3\n   country              log_gdp_per_cap .fitted\n   &lt;chr&gt;                          &lt;dbl&gt;   &lt;dbl&gt;\n 1 Aruba                          10.2     79.0\n 2 Afghanistan                     6.26    61.1\n 3 Angola                          7.50    66.7\n 4 Albania                         8.32    70.4\n 5 Andorra                        10.6     80.7\n 6 United Arab Emirates           10.6     80.8\n 7 Argentina                       9.45    75.5\n 8 Armenia                         8.17    69.7\n 9 American Samoa                  9.46    75.6\n10 Antigua and Barbuda             9.71    76.7\n# ℹ 207 more rows\n\n\nHow did the model do? What is the difference between what it predicted and the country’s observed average life expectancy? Compare .fitted (the predicted average life expectancy) to life_exp (the actual observed average life expectancy).\n\nm_eval &lt;- augment(m) |&gt; \n  transmute(\n    life_exp, \n    .fitted,\n    diff = life_exp - .fitted\n  )\n\nm_eval\n\n# A tibble: 203 × 3\n   life_exp .fitted   diff\n      &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1     75.6    79.0 -3.38 \n 2     63.1    61.1  2.05 \n 3     61.1    66.7 -5.61 \n 4     78.9    70.4  8.43 \n 5     79.3    80.8 -1.51 \n 6     76.3    75.5  0.797\n 7     74.7    69.7  4.95 \n 8     78.2    76.7  1.44 \n 9     82.4    81.7  0.753\n10     81.6    81.2  0.406\n# ℹ 193 more rows\n\n\nNote that broom::augment() already did this calculation and stored it in the .resid variable. The formal term for the difference between the predicted and observed values is the residual.\n\naugment(m) |&gt; \n  select(life_exp, .fitted, .resid)\n\n# A tibble: 203 × 3\n   life_exp .fitted .resid\n      &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n 1     75.6    79.0 -3.38 \n 2     63.1    61.1  2.05 \n 3     61.1    66.7 -5.61 \n 4     78.9    70.4  8.43 \n 5     79.3    80.8 -1.51 \n 6     76.3    75.5  0.797\n 7     74.7    69.7  4.95 \n 8     78.2    76.7  1.44 \n 9     82.4    81.7  0.753\n10     81.6    81.2  0.406\n# ℹ 193 more rows\n\n\nOkay, so there are some differences. Let’s look at those differences a bit more closely:\n\nggplot(augment(m), aes(x = .resid)) + \n  geom_density() + \n  geom_vline(xintercept = 0) + \n  theme_minimal()\n\n\n\n\n\n\n\nIf our model perfectly predicted each country’s life expectancy, we would see no difference between the predicted and observed values. There would just be a very tall straight line at 0 on the graph above.\nOur model hasn’t predicted life expectancy perfectly. Whilst most predictions are within a couple of years of the country’s true life expectancy, there are some that are very different (up to 10 or 15 years!). Where the model has got it wrong, it has tended to overestimate life expectancy (note that the peak of the density curve sits above 0).\nCan you see for which points these large differences exist?\n\nggplot(gapminder_df, aes(x = log_gdp_per_cap, y = life_exp)) + \n  geom_point() + \n  geom_smooth(method = \"lm\", se = F) + \n  theme_minimal() + \n  labs(x = \"Logged GDP per capita\",\n       y = \"Average life expectancy (years)\") + \n  scale_x_continuous(labels = label_dollar())\n\n\n\n\n\n\n\nWhat is causing these differences? A lot of your work as a political scientist is trying to answer this very question!\n(Random) error\nThe world is a messy and complicated place. Things often vary in random ways. That’s okay! It means that your observational data are going to move in funny and random ways. That’s okay too! As long as your model includes all of the systematic drivers of the thing you are interested in measuring (such as average life expectancy), we can accept a bit of random error.\nIn fact, we have already accounted for this. Remember that error term:\n\\[\nlife Exp_x = \\beta_0 + \\beta_1 logGdpPerCap_x + \\epsilon\n\\]\nWe run into issues when there are non-random things bundled up into the difference between what our model predicts and what we actually observe. We will discuss this more in later sessions.\nA model-wide value for error\nWe often want to understand how the model has performed as a whole, rather than how well it predicts each individual observed data point. There are many different ways we can do this.\nSum of squared residuals (deviance)\nThe sum of squared residuals measures the total error in our model. Formally:\n\\[\n\\Sigma(y_i - \\hat{y_i})^2\n\\]\nWhere \\(y_i\\) is each observed value (the country’s actual average life expectancy) and \\(\\hat{y_i}\\) is each predicted value (the model’s estimate of country’s average life expectancy). We just add those all up to get a single measure of the model’s overall performance.\nRemember that we tend to square things when we don’t care about their direction. We don’t care that the predicted value is less or more than the observed value, just about how far they are from each other.\nWe can do this ourselves:\n\naugment(m) |&gt; \n  summarise(sum(.resid^2))\n\n# A tibble: 1 × 1\n  `sum(.resid^2)`\n            &lt;dbl&gt;\n1           3366.\n\n\nOr we can use broom::glance():\n\nglance(m)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic  p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     0.724         0.722  4.09      526. 4.80e-58     1  -573. 1152. 1162.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\n\n\nglance(m) |&gt; \n  select(deviance)\n\n# A tibble: 1 × 1\n  deviance\n     &lt;dbl&gt;\n1    3366.\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhere broom::tidy() gives us information about the coefficients of our model, broom::glance() gives us information on the model overall.\n\n\nThis is useful, but it is influenced by the units by which we measure our variables. If one model includes something like GDP which is includes values in the billions, we will get a very large sum of squared residuals. If another model includes something like percentage of as state’s citizens who will vote for Donald Trump, we will get a relatively small sum of squared residuals. What if we want to compare model performance in a meaningful way?\n\\(R^2\\)\nThe \\(R^2\\) value measures the amount of variation in the dependent variable that is explained by the independent variable. In our example, it measures how much the changes in countries’ average life expectancy is explained by the changes in their (logged) GDP per capita.\n\\[\nR^2 = 1 - \\frac{Unexplained\\ variation}{Total\\ variation}\n\\]\nThe \\(R^2\\) value is useful because it does not reflect the units of measurement used in our variables. Therefore, we can compare how well different models perform.\nThe \\(R^2\\) value has three component parts.\nTotal Sum of Squares (TSS)\nTSS measures the squared sum of the differences between all predicted values of the dependent variable and the mean of the dependent variable.\nExplained Sum of Squares (ESS)\nESS measures the sum of the squares of the deviations of the predicted values from the mean value of the dependent variable.\nResidual Sum of Squares (RSS)\nRSS measures the difference between the TSS and ESS. In other words, the error not explained by the model.\nFormally, the \\(R^2\\) value is:\n\\[\nR^2 = 1 - \\frac{RSS}{TSS} = 1 - \\frac{\\Sigma(y_i - \\hat{y_i})^2}{\\Sigma(y_i - \\hat{y})^2}\n\\]\nOr:\n\\[\nR^2 = \\frac{ESS}{TSS} = \\frac{\\Sigma(\\hat{y}_i - \\bar{y})^2}{\\Sigma(y_i - \\bar{y})^2}\n\\]\nOur model’s \\(R^2\\) can be accessed using broom::glance():\n\nglance(m) |&gt; \n  select(r.squared)\n\n# A tibble: 1 × 1\n  r.squared\n      &lt;dbl&gt;\n1     0.724\n\n\nAn \\(R^2\\) of one means that all changes in the dependent variable are completely explained by changes in the independent variable. Here, it would mean that all changes to a country’s average life expectancy are explained through changes to the country’s logged GDP per capita.\nAccording to our model, 72.4% of changes in a country’s average life expectancy are explained through changes to the country’s logged GDP per capita.",
    "crumbs": [
      "Content",
      "Session 3",
      "Exploring the Relationship Between Two Variables"
    ]
  },
  {
    "objectID": "content/00-introduction.html",
    "href": "content/00-introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to GVPT399F: Power, Politics, and Data. This hands-on introduction to political science data analysis will (re)introduce you to R and statistics in an accessible and engaging way. We will avoid abstractions and jargon, opting instead for a hands-on, ground-up, and simulation-focused approach to understanding how these concepts and skills work. By the end of this winter, you’ll not only gain confidence in your ability to analyze and interpret data but also build in-demand skills valued in careers across government, international organizations, think tanks, and the private sector. No prior experience in statistics or coding (and definitely no ancient Greek) is needed—just bring your curiosity!",
    "crumbs": [
      "Content",
      "Session 0",
      "Introduction"
    ]
  },
  {
    "objectID": "content/00-introduction.html#what-this-course-covers",
    "href": "content/00-introduction.html#what-this-course-covers",
    "title": "Introduction",
    "section": "What this course covers",
    "text": "What this course covers\nAfter successfully completing this course you will be able to:\n\nUse R to collect, clean, and analyze data\nDescribe important features of your outcomes of interest and the variables you think drive changes to those outcomes\nIdentify and evaluate the relationship between two variables using statistical models\nDescribe those relationships using clear and precise language\nCritically evaluate empirical claims made in political news and analysis.",
    "crumbs": [
      "Content",
      "Session 0",
      "Introduction"
    ]
  },
  {
    "objectID": "content/00-introduction.html#course-structure",
    "href": "content/00-introduction.html#course-structure",
    "title": "Introduction",
    "section": "Course structure",
    "text": "Course structure\nThe course comprises six substantive sessions, this introductory session, and a session to conclude. You should complete these in order: each builds on the previous sessions.\nEach session includes some written content and a series of short recorded lectures. Each ends with a mandatory multiple-choice quiz (taken through ELMs). You will be introduced to new R code and statistical concepts in each session.\nThree substantive sessions will be released each week. You should complete them within that week. The quizzes for all three sessions released that week will be due at 11:59PM on Friday nights.\nYou will also complete a final exam at the end of the course. All material covered in all eight sessions could be tested.\nQuiz and exam schedule\n\n\n\n\n\n\n\n\nWEEK\nASSIGNMENT\nRELEASE DATE\nDUE DATE\n\n\n\n1\n0: Introduction quiz\n2 January 2025\n10 January 2025, 11:59PM\n\n\n2\n\n1: Session 1 quiz\n2: Session 2 quiz\n3: Session 3 quiz\n\n6 January 2025\n10 January 2025, 11:59PM\n\n\n3\n\n4: Session 4 quiz\n5: Session 5 quiz\n6: Session 6 quiz\n\n13 January 2025\n17 January 2025, 11:59PM\n\n\n4\n7: Final exam\n18 January 2025\n22 January 2025, 11:59PM\n\n\n\nPlease note: weeks one and four are short.",
    "crumbs": [
      "Content",
      "Session 0",
      "Introduction"
    ]
  },
  {
    "objectID": "content/00-introduction.html#course-resources",
    "href": "content/00-introduction.html#course-resources",
    "title": "Introduction",
    "section": "Course resources",
    "text": "Course resources\nEach session includes several resources written just for you. These can all be accessed from this website. They include:\n\na series of recorded lectures\ncorresponding slides with embedded R code\nsome written content.\n\nThere are no additional required readings for this course. Along the way, I may suggest other resources - book chapters, blog posts, videos, etc. - that you might find helpful. Sometimes it helps to hear these concepts explained in a couple of different ways.\nAdditional required resources\nTo complete this course, you need access to a personal computer and a stable internet connection. You also need to have access to the latest versions of R and RStudio. Here are detailed instructions on how to download or update these two free resources:\n Instructions on downloading R\n Instructions on downloading RStudio\nEverything you need to successfully complete this course is available for free.",
    "crumbs": [
      "Content",
      "Session 0",
      "Introduction"
    ]
  },
  {
    "objectID": "content/00-introduction.html#introduction-to-r-and-rstudio",
    "href": "content/00-introduction.html#introduction-to-r-and-rstudio",
    "title": "Introduction",
    "section": "Introduction to R and RStudio",
    "text": "Introduction to R and RStudio\n\n\nVideo\nSlides\n\n\n\n\n\n\n\n\n\n\n\n\nI will now introduce you to two tools you will use to successfully complete this course: R and RStudio.\nR is a versatile programming language that excels in statistical analysis. It is widely used by academics and in the private, government, and international sectors. You will certainly get a lot of use out of it going forward!\nR is also a very flexible language. You can make all kinds of very cool things with R, including websites, apps, slides, and more. In fact, all the resources I produced for this course were made using R, including this website and fancy slides.\nAnother advantage R has over other statistical programming languages is its accessibility. It is entirely free to use. There are many resources out there that will introduce you to its many uses. There is also an enthusiastic and welcoming community of R users who continue to grow R itself and the various resources you might need to expand your skills.\nR and RStudio\nSo, what is the difference between R and RStudio? R is the statistical programming language. RStudio is the platform, or integrated development environment, you will use to work with R. RStudio is free and used widely by R users.\nThe R skills you will learn\nThis course aims to provide you with two broad skills: statistical analysis and R. I will now outline what you will learn in relation to R.\nYou will learn how to import your data into R. You will learn how to load data stored in an external file, database, or online into a data frame in R.\nYou will then be introduced to methods for cleaning up those data. Oftentimes, data comes to us in a messy format, with missingness, and inconsistencies. You will need to tidy it up into a format that is easy to work with and consistent.\nOnce you have tidy data, you will then need to transform it so that it is ready for your analysis. This includes focusing your data on the observations you are interested in and creating new variables.\nNext, we will focus on visualizing your data. You can learn a lot more about your data and relationships lurking within it from a plot than you can from looking at the raw numbers.\nWe will also spend a fair chunk of time learning how to model those relationships within our data. Alongside visualization, this is where R excels.\nFinally, I will also introduce you to tools for communicating your findings in an engaging and replicable way.",
    "crumbs": [
      "Content",
      "Session 0",
      "Introduction"
    ]
  },
  {
    "objectID": "content/00-introduction.html#a-tour-of-rstudio",
    "href": "content/00-introduction.html#a-tour-of-rstudio",
    "title": "Introduction",
    "section": "A tour of RStudio",
    "text": "A tour of RStudio\n\n\nExercises\nUsing the console, find the summation of 45, 978, and 121.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nsum(45, 978, 121)\n\n[1] 1144\n\n\nOr:\n\n45 + 978 + 121\n\n[1] 1144\n\n\n\n\n\nWhat is 67 divided by 6?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\n67 / 6\n\n[1] 11.16667\n\n\n\n\n\nWhat is the square root of 894? Hint: use the sqrt() function.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nsqrt(894)\n\n[1] 29.89983",
    "crumbs": [
      "Content",
      "Session 0",
      "Introduction"
    ]
  },
  {
    "objectID": "content/00-introduction.html#quiz",
    "href": "content/00-introduction.html#quiz",
    "title": "Introduction",
    "section": "Quiz",
    "text": "Quiz\nHead over to ELMs to complete this session’s mandatory multiple-choice quiz.",
    "crumbs": [
      "Content",
      "Session 0",
      "Introduction"
    ]
  },
  {
    "objectID": "content/slides/00-01-intro_to_r_rstudio.html#learning-objectives-for-today",
    "href": "content/slides/00-01-intro_to_r_rstudio.html#learning-objectives-for-today",
    "title": "Introduction to R and RStudio",
    "section": "Learning objectives for today",
    "text": "Learning objectives for today\n\nIntroduction to R\nIntroduction to RStudio"
  },
  {
    "objectID": "content/slides/00-01-intro_to_r_rstudio.html#why-r",
    "href": "content/slides/00-01-intro_to_r_rstudio.html#why-r",
    "title": "Introduction to R and RStudio",
    "section": "Why R?",
    "text": "Why R?\n\nA versatile programming language\n\nAll materials used in this course were produced using R, including the website and fancy slides\n\nFree and accessible!"
  },
  {
    "objectID": "content/slides/00-01-intro_to_r_rstudio.html#r-and-rstudio",
    "href": "content/slides/00-01-intro_to_r_rstudio.html#r-and-rstudio",
    "title": "Introduction to R and RStudio",
    "section": "R and RStudio",
    "text": "R and RStudio\n\n\nR\nR is a free and open-source programming language and software environment for statistical computing and graphics.\n\nRStudio\nRStudio is an integrated development environment (IDE) for the R programming language.\n\n\n\nInstructions on how to download R and RStudio are provided in the Install or upgrade R and RStudio chapter in Jennifer Bryan’s Happy Git and GitHub for the useR."
  },
  {
    "objectID": "content/slides/00-01-intro_to_r_rstudio.html#the-r-skills-you-will-learn",
    "href": "content/slides/00-01-intro_to_r_rstudio.html#the-r-skills-you-will-learn",
    "title": "Introduction to R and RStudio",
    "section": "The R skills you will learn",
    "text": "The R skills you will learn\nThis course will introduce you to both statistics and R. Focusing on R, you will learn how to:\n\nImport your data into R\nTidy your data\nTransform it\nVisualize it\nModel patterns and relationships within it\nCommunicate your findings."
  },
  {
    "objectID": "content/slides/00-01-intro_to_r_rstudio.html#a-tour-of-rstudio",
    "href": "content/slides/00-01-intro_to_r_rstudio.html#a-tour-of-rstudio",
    "title": "Introduction to R and RStudio",
    "section": "A Tour of RStudio",
    "text": "A Tour of RStudio\n\nSource: R4DS"
  },
  {
    "objectID": "content/slides/00-01-intro_to_r_rstudio.html#summary",
    "href": "content/slides/00-01-intro_to_r_rstudio.html#summary",
    "title": "Introduction to R and RStudio",
    "section": "Summary",
    "text": "Summary\nThis session you:\n\nLearnt about new data science tools to help you conduct replicable and reproducible political science research\nSet up your data science tools"
  },
  {
    "objectID": "content/02-01-transformation.html",
    "href": "content/02-01-transformation.html",
    "title": "Data Transformation",
    "section": "",
    "text": "To complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(\"gapminder\")\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\nThis section focuses on introducing you to some new R skills. Data rarely come to us perfectly formatted and without annoying errors or inconsistencies. We can use R to clean our data up and get them ready for analysis.",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#set-up",
    "href": "content/02-01-transformation.html#set-up",
    "title": "Data Transformation",
    "section": "",
    "text": "To complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(\"gapminder\")\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\nThis section focuses on introducing you to some new R skills. Data rarely come to us perfectly formatted and without annoying errors or inconsistencies. We can use R to clean our data up and get them ready for analysis.",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#gapminder",
    "href": "content/02-01-transformation.html#gapminder",
    "title": "Data Transformation",
    "section": "Gapminder",
    "text": "Gapminder\nThis session, we will explore the long-studied relationship between countries’ health and wealth. Attention was brought to this relationship by the Gapminder project. You can read more about their research here.\nBefore we get started, check out this video that describes (very enthusiastically) the relationship between health and wealth:",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#introduction",
    "href": "content/02-01-transformation.html#introduction",
    "title": "Data Transformation",
    "section": "Introduction",
    "text": "Introduction\n\n\nToday, I am going to introduce you to some of my most widely used functions in R. The dplyr R package, which houses these functions, focuses on providing you with some very helpful tools to tidy your data. This step in the data analysis process is critical, and often one of the most time consuming, so let’s get started!\nR objects\nAs a reminder, objects sit in R’s memory. You can see which ones exist in your current session and their values over in the environment tab.\nTo create a new object, use: &lt;-. You can update that object at any time.\n\n\n\n\n\n\nNote\n\n\n\nSome people use = instead of &lt;-. I strongly recommend against this. It makes your script difficult to read, and it can lead to syntax errors.\n\n\nR functions\nFunctions are helpful short-hands that perform specific tasks in R. Many of these functions come straight out of the box with R. For example, you can run the following code without loading any packages into your current session:\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe seq() function takes three main arguments: a start value, end value, and interval value. Above I have asked it to start at 1 and end at 10. By default, its interval value is 1. Therefore, its output is every whole number from 1 to 10.\n\n\nYou can even create objects with R functions:\n\nx &lt;- seq(1, 10)\n\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nNow, the x object is a vector of all 10 whole numbers from 1 to 10.\nData\nAs mentioned above, we are going to be using the Gapminder project’s data on countries’ health and wealth to explore data transformation. Happily, there is an R package that provides that data for us. We will now install it:\n\ninstall.packages(\"gapminder\")\n\nNext, you want to create a new script for this session. At the top of that script, include the code to load in the packages we will be using today:\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\nYou can now access the Gapminder data directly:\n\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nAbove, R prints out some useful information about our data. First, we learn that it is a tibble. This is the tidyverse version of a data frame.\nSecond, we learn how many rows and columns are included in our data set. We have 1,704 rows and 6 columns.\nNext, we learn the column (or variable) titles:\n\ncolnames(gapminder)\n\n[1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n\n\nNext, we see some funny looking three letter words under each column name. These refer to the column’s data type. We will discuss these below.\nFinally, we see the first few rows of our data set. We can see that each row provides a country’s information in a single year.\nData types\nThose funny three-letter words refer to the column’s data type. In this data set, we have three different types:\n\n&lt;fct&gt;, which stands for factor (R’s word for categorical variable)\n&lt;int&gt;, which stands for integer\n&lt;dbl&gt;, which stands for double (or real number)\n\nSome other common data types include:\n\n&lt;chr&gt;, which stands for character (or string)\n&lt;dttm&gt;, which stands for date-time\n&lt;lgl&gt;, which stands for local (which can only be TRUE or FALSE)\n\nData types are important because each column can only contain one data type. You cannot, for example, include a character in an integer column (imagine trying to run some calculation on that column: how would R treat the stray character value?).\n\ndplyr basics\nNow we know a little bit more about our data set, we are going to use it to explore five of the most commonly used functions in R:\n\nfilter()\narrange()\nselect()\nmutate()\nsummarise()\nExercises\nWhat is the unit of observation for the gapminder data set?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\nThe unit of observation is country-year.\n\n\n\nHow many country-years are included in the gapminder data set?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nnrow(gapminder)\n\n[1] 1704\n\n\n\n\n\nWhich two variables in the gapminder data set are factors?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\ncountry and continent are factors (or categorical variables).",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#filtering-your-data",
    "href": "content/02-01-transformation.html#filtering-your-data",
    "title": "Data Transformation",
    "section": "Filtering your data",
    "text": "Filtering your data\n\n\nWe are going to start by learning how to filter our data to only include those observations we are interested in exploring.\nAll dplyr functions are structured the same way. They take the data object you want to transform as their first argument. You then need to identify the columns within that data object you want to transform and what you want to do with them.\nFor example, the following code takes our data set, gapminder, and tells filter() that we want to only include rows in which the country column matches “Australia” and the year column is greater than 2000:\n\nfilter(gapminder, country == \"Australia\", year &gt; 2000)\n\n# A tibble: 2 × 6\n  country   continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Australia Oceania    2002    80.4 19546792    30688.\n2 Australia Oceania    2007    81.2 20434176    34435.\n\n\nWe can ask filter() to include rows that match multiple values:\n\nfilter(gapminder, continent %in% c(\"Asia\", \"Oceania\"))\n\n# A tibble: 420 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 410 more rows\n\n\nHere, I have used the %in% value and a vector (which is c(...)) of strings to ask filter to include all rows in which the continent column matches the values “Asia” and “Oceania”.\nWe can ask filter() to include values within a range. The following code asks filter() to include all rows in which the pop column is greater than 500,000 and less than 1,000,000:\n\nfilter(gapminder, pop &gt; 500000 & pop &lt; 1000000)\n\n# A tibble: 88 × 6\n   country  continent  year lifeExp    pop gdpPercap\n   &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;  &lt;int&gt;     &lt;dbl&gt;\n 1 Bahrain  Asia       1992    72.6 529491    19036.\n 2 Bahrain  Asia       1997    73.9 598561    20292.\n 3 Bahrain  Asia       2002    74.8 656397    23404.\n 4 Bahrain  Asia       2007    75.6 708573    29796.\n 5 Botswana Africa     1962    51.5 512764      984.\n 6 Botswana Africa     1967    53.3 553541     1215.\n 7 Botswana Africa     1972    56.0 619351     2264.\n 8 Botswana Africa     1977    59.3 781472     3215.\n 9 Botswana Africa     1982    61.5 970347     4551.\n10 Comoros  Africa     1997    60.7 527982     1174.\n# ℹ 78 more rows\n\n\nThe following code asks filter() to include all rows in which the pop column is greater than 500,000 or less than 1,000,000.\n\nfilter(gapminder, pop &gt; 500000 | pop &lt; 1000000)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nR includes some handy operators:\n\n== is equal to\n!= is not equal to\n&gt;= is greater than or equal to\n&lt;= is less than or equal to\n| is OR\n& is AND\n%in% is in\n\nExercises\nFind all country-years that have populations greater than 1 billion people.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nfilter(gapminder, pop &gt; 1e9)\n\n# A tibble: 8 × 6\n  country continent  year lifeExp        pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n1 China   Asia       1982    65.5 1000281000      962.\n2 China   Asia       1987    67.3 1084035000     1379.\n3 China   Asia       1992    68.7 1164970000     1656.\n4 China   Asia       1997    70.4 1230075000     2289.\n5 China   Asia       2002    72.0 1280400000     3119.\n6 China   Asia       2007    73.0 1318683096     4959.\n7 India   Asia       2002    62.9 1034172547     1747.\n8 India   Asia       2007    64.7 1110396331     2452.\n\n\nNote: 1e9 is scientific notation for 1 billion (which has nine zeros).\n\n\n\nFind all countries in Oceania.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nfilter(gapminder, continent == \"Oceania\")\n\n# A tibble: 24 × 6\n   country   continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Australia Oceania    1952    69.1  8691212    10040.\n 2 Australia Oceania    1957    70.3  9712569    10950.\n 3 Australia Oceania    1962    70.9 10794968    12217.\n 4 Australia Oceania    1967    71.1 11872264    14526.\n 5 Australia Oceania    1972    71.9 13177000    16789.\n 6 Australia Oceania    1977    73.5 14074100    18334.\n 7 Australia Oceania    1982    74.7 15184200    19477.\n 8 Australia Oceania    1987    76.3 16257249    21889.\n 9 Australia Oceania    1992    77.6 17481977    23425.\n10 Australia Oceania    1997    78.8 18565243    26998.\n# ℹ 14 more rows\n\n\n\n\n\nFind all countries in both Asia and Europe.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nfilter(gapminder, continent %in% c(\"Asia\", \"Europe\"))\n\n# A tibble: 756 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 746 more rows\n\n\n\n\n\nFind all country-years that have a life expectancy greater than 50 years and less than 60 years.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nfilter(gapminder, lifeExp &gt; 50 & lifeExp &lt; 60)\n\n# A tibble: 336 × 6\n   country    continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;      &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Albania    Europe     1952    55.2  1282697     1601.\n 2 Albania    Europe     1957    59.3  1476505     1942.\n 3 Algeria    Africa     1967    51.4 12760499     3247.\n 4 Algeria    Africa     1972    54.5 14760787     4183.\n 5 Algeria    Africa     1977    58.0 17152804     4910.\n 6 Bahrain    Asia       1952    50.9   120447     9867.\n 7 Bahrain    Asia       1957    53.8   138655    11636.\n 8 Bahrain    Asia       1962    56.9   171863    12753.\n 9 Bahrain    Asia       1967    59.9   202182    14805.\n10 Bangladesh Asia       1982    50.0 93074406      677.\n# ℹ 326 more rows\n\n\n\n\n\nFind all country-years that have a life expectancy less than 50 years or greater than 60 years.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nfilter(gapminder, lifeExp &lt; 50 | lifeExp &gt; 60)\n\n# A tibble: 1,368 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,358 more rows",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#sorting-your-data",
    "href": "content/02-01-transformation.html#sorting-your-data",
    "title": "Data Transformation",
    "section": "Sorting your data",
    "text": "Sorting your data\n\n\nWe can control the order of our data using arrange(). The following code sorts our data by country name (alphabetically) and year (in ascending numerical order):\n\narrange(gapminder, country, year)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nTo sort in descending order, simply wrap your column name in the desc() function:\n\narrange(gapminder, country, desc(year))\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       2007    43.8 31889923      975.\n 2 Afghanistan Asia       2002    42.1 25268405      727.\n 3 Afghanistan Asia       1997    41.8 22227415      635.\n 4 Afghanistan Asia       1992    41.7 16317921      649.\n 5 Afghanistan Asia       1987    40.8 13867957      852.\n 6 Afghanistan Asia       1982    39.9 12881816      978.\n 7 Afghanistan Asia       1977    38.4 14880372      786.\n 8 Afghanistan Asia       1972    36.1 13079460      740.\n 9 Afghanistan Asia       1967    34.0 11537966      836.\n10 Afghanistan Asia       1962    32.0 10267083      853.\n# ℹ 1,694 more rows\n\n\nYou can combine arrange() and filter() using the slice_X() functions. For example, you can filter for the smallest value in a column using slice_min(). The following code filters for the smallest value in the lifeExp column:\n\nslice_min(gapminder, lifeExp)\n\n# A tibble: 1 × 6\n  country continent  year lifeExp     pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n1 Rwanda  Africa     1992    23.6 7290203      737.\n\n\nThe following code filters for the largest value in this column:\n\nslice_max(gapminder, lifeExp)\n\n# A tibble: 1 × 6\n  country continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Japan   Asia       2007    82.6 127467972    31656.\n\n\nExercises\nWhich country-year has the lowest life expectancy?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\narrange(gapminder, lifeExp)\n\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# ℹ 1,694 more rows\n\n\nNote: check out slice_min() and slice_max() for more efficient ways of doing this.\n\n\n\nWhich country-year has the largest population?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\narrange(gapminder, desc(pop))\n\n# A tibble: 1,704 × 6\n   country continent  year lifeExp        pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n 1 China   Asia       2007    73.0 1318683096     4959.\n 2 China   Asia       2002    72.0 1280400000     3119.\n 3 China   Asia       1997    70.4 1230075000     2289.\n 4 China   Asia       1992    68.7 1164970000     1656.\n 5 India   Asia       2007    64.7 1110396331     2452.\n 6 China   Asia       1987    67.3 1084035000     1379.\n 7 India   Asia       2002    62.9 1034172547     1747.\n 8 China   Asia       1982    65.5 1000281000      962.\n 9 India   Asia       1997    61.8  959000000     1459.\n10 China   Asia       1977    64.0  943455000      741.\n# ℹ 1,694 more rows\n\n\nNote: check out slice_min() and slice_max() for more efficient ways of doing this.",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#selecting-relevant-columns",
    "href": "content/02-01-transformation.html#selecting-relevant-columns",
    "title": "Data Transformation",
    "section": "Selecting relevant columns",
    "text": "Selecting relevant columns\n\n\nYou can focus your data set on only those variables you are interested in using select(). The following code selects only the country, year, and pop variables from our larger gapminder data set:\n\nselect(gapminder, country, year, pop)\n\n# A tibble: 1,704 × 3\n   country      year      pop\n   &lt;fct&gt;       &lt;int&gt;    &lt;int&gt;\n 1 Afghanistan  1952  8425333\n 2 Afghanistan  1957  9240934\n 3 Afghanistan  1962 10267083\n 4 Afghanistan  1967 11537966\n 5 Afghanistan  1972 13079460\n 6 Afghanistan  1977 14880372\n 7 Afghanistan  1982 12881816\n 8 Afghanistan  1987 13867957\n 9 Afghanistan  1992 16317921\n10 Afghanistan  1997 22227415\n# ℹ 1,694 more rows\n\n\ndplyr includes some operators that help keep your code clean when working with a lot of data. For example, you can use a colon (:) to select all columns between two columns:\n\nselect(gapminder, country:pop)\n\n# A tibble: 1,704 × 5\n   country     continent  year lifeExp      pop\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;\n 1 Afghanistan Asia       1952    28.8  8425333\n 2 Afghanistan Asia       1957    30.3  9240934\n 3 Afghanistan Asia       1962    32.0 10267083\n 4 Afghanistan Asia       1967    34.0 11537966\n 5 Afghanistan Asia       1972    36.1 13079460\n 6 Afghanistan Asia       1977    38.4 14880372\n 7 Afghanistan Asia       1982    39.9 12881816\n 8 Afghanistan Asia       1987    40.8 13867957\n 9 Afghanistan Asia       1992    41.7 16317921\n10 Afghanistan Asia       1997    41.8 22227415\n# ℹ 1,694 more rows\n\n\nYou can use a negative sign (-) to specify which columns you want to exclude:\n\nselect(gapminder, -(lifeExp:pop))\n\n# A tibble: 1,704 × 4\n   country     continent  year gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952      779.\n 2 Afghanistan Asia       1957      821.\n 3 Afghanistan Asia       1962      853.\n 4 Afghanistan Asia       1967      836.\n 5 Afghanistan Asia       1972      740.\n 6 Afghanistan Asia       1977      786.\n 7 Afghanistan Asia       1982      978.\n 8 Afghanistan Asia       1987      852.\n 9 Afghanistan Asia       1992      649.\n10 Afghanistan Asia       1997      635.\n# ℹ 1,694 more rows\n\n\nExercises\nSelect only the country, year, and lifeExp variables from gapminder.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nselect(gapminder, country, year, lifeExp)\n\n# A tibble: 1,704 × 3\n   country      year lifeExp\n   &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;\n 1 Afghanistan  1952    28.8\n 2 Afghanistan  1957    30.3\n 3 Afghanistan  1962    32.0\n 4 Afghanistan  1967    34.0\n 5 Afghanistan  1972    36.1\n 6 Afghanistan  1977    38.4\n 7 Afghanistan  1982    39.9\n 8 Afghanistan  1987    40.8\n 9 Afghanistan  1992    41.7\n10 Afghanistan  1997    41.8\n# ℹ 1,694 more rows\n\n\n\n\n\nWhat does the any_of() function do? Why might it be helpful in conjunction with this vector?\n\nvars &lt;- c(\"country\", \"year\", \"lifeExp\", \"boop\")\n\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nselect(gapminder, any_of(vars))\n\n# A tibble: 1,704 × 3\n   country      year lifeExp\n   &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;\n 1 Afghanistan  1952    28.8\n 2 Afghanistan  1957    30.3\n 3 Afghanistan  1962    32.0\n 4 Afghanistan  1967    34.0\n 5 Afghanistan  1972    36.1\n 6 Afghanistan  1977    38.4\n 7 Afghanistan  1982    39.9\n 8 Afghanistan  1987    40.8\n 9 Afghanistan  1992    41.7\n10 Afghanistan  1997    41.8\n# ℹ 1,694 more rows\n\n\n\n\n\nWhat does the following code produce?\n\nselect(gapminder, starts_with(\"c\"))\n\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nselect(gapminder, starts_with(\"c\"))\n\n# A tibble: 1,704 × 2\n   country     continent\n   &lt;fct&gt;       &lt;fct&gt;    \n 1 Afghanistan Asia     \n 2 Afghanistan Asia     \n 3 Afghanistan Asia     \n 4 Afghanistan Asia     \n 5 Afghanistan Asia     \n 6 Afghanistan Asia     \n 7 Afghanistan Asia     \n 8 Afghanistan Asia     \n 9 Afghanistan Asia     \n10 Afghanistan Asia     \n# ℹ 1,694 more rows",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#create-or-change-columns-of-data",
    "href": "content/02-01-transformation.html#create-or-change-columns-of-data",
    "title": "Data Transformation",
    "section": "Create or change columns of data",
    "text": "Create or change columns of data\n\n\nOftentimes, we need to create new columns from existing ones or change in a consistent way existing columns of data. You can use mutate() to do this. For example, the following code creates a new column, gdp, which is the product of gdpPercap and pop:\n\nmutate(gapminder, gdp = gdpPercap * pop)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n# ℹ 1,694 more rows\n\n\nThe following code transforms the existing column gdpPercap to its logged form:\n\nmutate(gapminder, gdpPercap = log(gdpPercap))\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      6.66\n 2 Afghanistan Asia       1957    30.3  9240934      6.71\n 3 Afghanistan Asia       1962    32.0 10267083      6.75\n 4 Afghanistan Asia       1967    34.0 11537966      6.73\n 5 Afghanistan Asia       1972    36.1 13079460      6.61\n 6 Afghanistan Asia       1977    38.4 14880372      6.67\n 7 Afghanistan Asia       1982    39.9 12881816      6.89\n 8 Afghanistan Asia       1987    40.8 13867957      6.75\n 9 Afghanistan Asia       1992    41.7 16317921      6.48\n10 Afghanistan Asia       1997    41.8 22227415      6.45\n# ℹ 1,694 more rows\n\n\nYou can combine select() and mutate() using the transmute() function:\n\ntransmute(gapminder, country, year, gdp = gdpPercap * pop)\n\n# A tibble: 1,704 × 3\n   country      year          gdp\n   &lt;fct&gt;       &lt;int&gt;        &lt;dbl&gt;\n 1 Afghanistan  1952  6567086330.\n 2 Afghanistan  1957  7585448670.\n 3 Afghanistan  1962  8758855797.\n 4 Afghanistan  1967  9648014150.\n 5 Afghanistan  1972  9678553274.\n 6 Afghanistan  1977 11697659231.\n 7 Afghanistan  1982 12598563401.\n 8 Afghanistan  1987 11820990309.\n 9 Afghanistan  1992 10595901589.\n10 Afghanistan  1997 14121995875.\n# ℹ 1,694 more rows\n\n\nExercises\nCreate a new variable that provides each country-year’s GDP (which you can get by multiplying its GDP with its population).\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nmutate(gapminder, gdp = gdpPercap * pop)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n# ℹ 1,694 more rows\n\n\n\n\n\nCreate a new data set that only includes information on each country-year’s name, year, and GDP.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\ntransmute(gapminder, country, year, gdp = gdpPercap * pop)\n\n# A tibble: 1,704 × 3\n   country      year          gdp\n   &lt;fct&gt;       &lt;int&gt;        &lt;dbl&gt;\n 1 Afghanistan  1952  6567086330.\n 2 Afghanistan  1957  7585448670.\n 3 Afghanistan  1962  8758855797.\n 4 Afghanistan  1967  9648014150.\n 5 Afghanistan  1972  9678553274.\n 6 Afghanistan  1977 11697659231.\n 7 Afghanistan  1982 12598563401.\n 8 Afghanistan  1987 11820990309.\n 9 Afghanistan  1992 10595901589.\n10 Afghanistan  1997 14121995875.\n# ℹ 1,694 more rows",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#summarize-your-data",
    "href": "content/02-01-transformation.html#summarize-your-data",
    "title": "Data Transformation",
    "section": "Summarize your data",
    "text": "Summarize your data\n\n\nFinally, you can summarize (or aggregate) your data. For example, we often want to find the average of our observations. The following code finds the average population and GDP per capita for all country-years in our data set:\n\nsummarise(\n  gapminder, avg_pop = mean(pop), avg_gdp_per_cap = mean(gdpPercap)\n)\n\n# A tibble: 1 × 2\n    avg_pop avg_gdp_per_cap\n      &lt;dbl&gt;           &lt;dbl&gt;\n1 29601212.           7215.\n\n\nNote that the output is now one row long.\nThe following finds both the average and mean of our country-years’ populations and GDPs per capita:\n\nsummarise(\n  gapminder, \n  avg_pop = mean(pop), \n  median_pop = median(pop), \n  avg_gdp_per_cap = mean(gdpPercap),\n  median_gdp_per_cap = median(gdpPercap)\n)\n\n# A tibble: 1 × 4\n    avg_pop median_pop avg_gdp_per_cap median_gdp_per_cap\n      &lt;dbl&gt;      &lt;dbl&gt;           &lt;dbl&gt;              &lt;dbl&gt;\n1 29601212.   7023596.           7215.              3532.\n\n\nSometimes, we want to summarize our data within meaningful groups. For example, we may want to find the average population and GDP per capita for each continent included in our data set. To do this, you need to use the group_by() function to group your data. You can then use the summarise() function to summarize it within those groups:\n\ngapminder_continent &lt;- group_by(gapminder, continent)\n\nsummarise(\n  gapminder_continent, \n  avg_pop = mean(pop), \n  avg_gdp_per_cap = mean(gdpPercap)\n)\n\n# A tibble: 5 × 3\n  continent   avg_pop avg_gdp_per_cap\n  &lt;fct&gt;         &lt;dbl&gt;           &lt;dbl&gt;\n1 Africa     9916003.           2194.\n2 Americas  24504795.           7136.\n3 Asia      77038722.           7902.\n4 Europe    17169765.          14469.\n5 Oceania    8874672.          18622.\n\n\nExercises\nCalculate each country-year’s GDP.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nmutate(gapminder, gdp = pop * gdpPercap)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n# ℹ 1,694 more rows\n\n\n\n\n\nFind each country’s average GDP across all years in the gapminder data set.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\ngapminder_country &lt;- group_by(gapminder, country)\n\ngapminder_country_avg &lt;- summarise(\n  mutate(gapminder_country, gdp = pop * gdpPercap), avg_gdp = mean(gdp)\n)\n\ngapminder_country_avg\n\n# A tibble: 142 × 2\n   country           avg_gdp\n   &lt;fct&gt;               &lt;dbl&gt;\n 1 Afghanistan  12709647583.\n 2 Albania       9094669267.\n 3 Algeria      96735171261.\n 4 Angola       25532681843.\n 5 Argentina   266754123835.\n 6 Australia   320253755823.\n 7 Austria     158579002935.\n 8 Bahrain       7694793798.\n 9 Bangladesh   80648494456.\n10 Belgium     197371599665.\n# ℹ 132 more rows\n\n\n\n\n\nFind the country with the smallest average GDP across these years.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\narrange(gapminder_country_avg, avg_gdp)\n\n# A tibble: 142 × 2\n   country                   avg_gdp\n   &lt;fct&gt;                       &lt;dbl&gt;\n 1 Sao Tome and Principe  151723722.\n 2 Comoros                450509962.\n 3 Gambia                 551998132.\n 4 Guinea-Bissau          583673324.\n 5 Djibouti               647199614.\n 6 Liberia               1054141313.\n 7 Equatorial Guinea     1143738921.\n 8 Lesotho               1257957241.\n 9 Eritrea               1683400010.\n10 Burundi               2253225196.\n# ℹ 132 more rows\n\n\n\n\n\nFind the country with the largest average GDP across these years.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\narrange(gapminder_country_avg, desc(avg_gdp))\n\n# A tibble: 142 × 2\n   country        avg_gdp\n   &lt;fct&gt;            &lt;dbl&gt;\n 1 United States  6.40e12\n 2 Japan          2.12e12\n 3 China          1.70e12\n 4 Germany        1.62e12\n 5 United Kingdom 1.11e12\n 6 France         1.04e12\n 7 Italy          9.11e11\n 8 India          8.62e11\n 9 Brazil         8.11e11\n10 Mexico         5.95e11\n# ℹ 132 more rows",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/02-01-transformation.html#the-pipe",
    "href": "content/02-01-transformation.html#the-pipe",
    "title": "Data Transformation",
    "section": "The pipe",
    "text": "The pipe\n\n\nThat got messy! We had a lot of different objects representing intermediate steps in our calculations, but we never need those objects again. Can we avoid creating them?\nLet’s introduce perhaps the defining feature of the tidyverse: the pipe.\nRead the pipe (|&gt;) as:\nTake this |&gt; (and then…)\ndo this |&gt; (and then…)\ndo this\nFor example:\n\ngapminder |&gt; \n  group_by(continent) |&gt; \n  summarise(avg_pop = mean(pop), avg_gdp_per_cap = mean(gdpPercap)) |&gt;\n  arrange(avg_gdp_per_cap)\n\n# A tibble: 5 × 3\n  continent   avg_pop avg_gdp_per_cap\n  &lt;fct&gt;         &lt;dbl&gt;           &lt;dbl&gt;\n1 Africa     9916003.           2194.\n2 Americas  24504795.           7136.\n3 Asia      77038722.           7902.\n4 Europe    17169765.          14469.\n5 Oceania    8874672.          18622.\n\n\nReads as:\n\nTake the gapminder data set, and then…\nGroup it by continent, and then…\nFind the average population and GDP per capita for each of those continents, and then…\nSort those summaries by their average GDPs per capita (in ascending order).\n\nYou can combine all tidyverse functions with the pipe:\n\ngapminder |&gt; \n  group_by(continent) |&gt; \n  summarise(avg_pop = mean(pop), avg_gdp_per_cap = mean(gdpPercap)) |&gt; \n  ggplot(aes(x = continent, y = avg_gdp_per_cap)) + \n  geom_col() + \n  theme_minimal()\n\n\n\n\n\n\n\nIt is worth noting that there are two versions of the pipe running around. The first |&gt; is the base pipe. This comes straight out of the box with R. You do not need to load in any packages to use it. The second, %&gt;%, is the tidyverse pipe. To use it, you need to load in either dplyr or the magrittr package.\nI have switched to using the base pipe, so that’s the one you will see in all of my code. You can use whichever you prefer!\nExercises\nUse the pipe to calculate the average GDP per capita for countries in the Americas in all years including or after 2000.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\ngapminder_americas_2000 &lt;- gapminder |&gt; \n  filter(continent == \"Americas\", year &gt; 2000) |&gt; \n  group_by(country) |&gt; \n  summarise(avg_gdp_per_cap = mean(gdpPercap))\n\ngapminder_americas_2000\n\n# A tibble: 25 × 2\n   country            avg_gdp_per_cap\n   &lt;fct&gt;                        &lt;dbl&gt;\n 1 Argentina                   10789.\n 2 Bolivia                      3618.\n 3 Brazil                       8599.\n 4 Canada                      34824.\n 5 Chile                       11975.\n 6 Colombia                     6381.\n 7 Costa Rica                   8684.\n 8 Cuba                         7644.\n 9 Dominican Republic           5295.\n10 Ecuador                      6323.\n# ℹ 15 more rows\n\n\n\n\n\nPlot your results.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nggplot(gapminder_americas_2000, aes(x = avg_gdp_per_cap, y = reorder(country, avg_gdp_per_cap))) + \n  geom_col() +\n  theme_minimal() + \n  labs(title = \"Average GDP per capita for countries in the Americas in 2002 and 2007\",\n       x = \"Average GDP per capita (US$)\",\n       y = NULL) + \n  scale_x_continuous(labels = scales::label_dollar())\n\n\n\n\n\n\n\nNote: Check out the scales R package for very handy formatting functions: https://scales.r-lib.org.",
    "crumbs": [
      "Content",
      "Session 2",
      "Data Transformation"
    ]
  },
  {
    "objectID": "content/slides/02-01-transformation_intro.html#learning-objectives",
    "href": "content/slides/02-01-transformation_intro.html#learning-objectives",
    "title": "Data Transformation",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nLearn basic operations in R\nBe introduced to dplyr\nClean up and transform your data"
  },
  {
    "objectID": "content/slides/02-01-transformation_intro.html#r-objects",
    "href": "content/slides/02-01-transformation_intro.html#r-objects",
    "title": "Data Transformation",
    "section": "R objects",
    "text": "R objects\nCreate new objects with &lt;-\n\nx &lt;- 3 * 4\n\nx\n\n[1] 12\n\n\n\n\nx &lt;- 3 * 10\n\nx\n\n[1] 30\n\n\n\n\nSome people use = instead of &lt;-. I strongly recommend against this. It makes your script difficult to read, and it can lead to syntax errors."
  },
  {
    "objectID": "content/slides/02-01-transformation_intro.html#r-functions",
    "href": "content/slides/02-01-transformation_intro.html#r-functions",
    "title": "Data Transformation",
    "section": "R functions",
    "text": "R functions\nMany functions come with R straight out of the box:\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\nYou can create objects using functions:\n\nx &lt;- seq(1, 10)\n\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10"
  },
  {
    "objectID": "content/slides/02-01-transformation_intro.html#gapminder",
    "href": "content/slides/02-01-transformation_intro.html#gapminder",
    "title": "Data Transformation",
    "section": "Gapminder",
    "text": "Gapminder\nFirst, you need to install the gapminder package:\n\ninstall.packages(\"gapminder\")\n\nThen access the gapminder data set:\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786."
  },
  {
    "objectID": "content/slides/02-01-transformation_intro.html#data-types",
    "href": "content/slides/02-01-transformation_intro.html#data-types",
    "title": "Data Transformation",
    "section": "Data types",
    "text": "Data types\nIn gapminder:\n\nfctr stands for factors, which R uses to represent categorical variables with fixed possible values.\nint stands for integer.\ndbl stands for doubles (or real numbers)."
  },
  {
    "objectID": "content/slides/02-01-transformation_intro.html#data-types-1",
    "href": "content/slides/02-01-transformation_intro.html#data-types-1",
    "title": "Data Transformation",
    "section": "Data types",
    "text": "Data types\nOther types:\n\nchr stands for character vectors, or strings.\ndttm stands for date-times (a date + a time).\nlgl stands for logical, vectors that contain only TRUE or FALSE.1\n\nTRUE can be shortened to T and FALSE can be shortened to F."
  },
  {
    "objectID": "content/slides/02-01-transformation_intro.html#introducing-dplyr",
    "href": "content/slides/02-01-transformation_intro.html#introducing-dplyr",
    "title": "Data Transformation",
    "section": "Introducing dplyr",
    "text": "Introducing dplyr\nHelp you with most of your data transformation needs.\nFive basic functions:\n\nfilter()\narrange()\nselect()\nmutate()\nsummarise()"
  },
  {
    "objectID": "content/slides/02-02-filter.html#dplyr-basics",
    "href": "content/slides/02-02-filter.html#dplyr-basics",
    "title": "Filtering Your Data",
    "section": "dplyr basics",
    "text": "dplyr basics\n\nFirst argument is always a data object (for example, a dataframe).\nSubsequent arguments typically describe which columns to operate on, using the variable names (without quotes).\nOutput is always a new data object."
  },
  {
    "objectID": "content/slides/02-02-filter.html#filter-rows-with-filter",
    "href": "content/slides/02-02-filter.html#filter-rows-with-filter",
    "title": "Filtering Your Data",
    "section": "Filter rows with filter()",
    "text": "Filter rows with filter()\n\nfilter(gapminder, country == \"Australia\", year &gt; 2000)\n\n# A tibble: 2 × 6\n  country   continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Australia Oceania    2002    80.4 19546792    30688.\n2 Australia Oceania    2007    81.2 20434176    34435."
  },
  {
    "objectID": "content/slides/02-02-filter.html#filter-rows-with-filter-1",
    "href": "content/slides/02-02-filter.html#filter-rows-with-filter-1",
    "title": "Filtering Your Data",
    "section": "Filter rows with filter()",
    "text": "Filter rows with filter()\n\nfilter(gapminder, continent %in% c(\"Asia\", \"Oceania\"))\n\n# A tibble: 420 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 410 more rows"
  },
  {
    "objectID": "content/slides/02-02-filter.html#filter-rows-with-filter-2",
    "href": "content/slides/02-02-filter.html#filter-rows-with-filter-2",
    "title": "Filtering Your Data",
    "section": "Filter rows with filter()",
    "text": "Filter rows with filter()\n\nfilter(gapminder, pop &gt; 500000 & pop &lt; 1000000)\n\n# A tibble: 88 × 6\n   country  continent  year lifeExp    pop gdpPercap\n   &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;  &lt;int&gt;     &lt;dbl&gt;\n 1 Bahrain  Asia       1992    72.6 529491    19036.\n 2 Bahrain  Asia       1997    73.9 598561    20292.\n 3 Bahrain  Asia       2002    74.8 656397    23404.\n 4 Bahrain  Asia       2007    75.6 708573    29796.\n 5 Botswana Africa     1962    51.5 512764      984.\n 6 Botswana Africa     1967    53.3 553541     1215.\n 7 Botswana Africa     1972    56.0 619351     2264.\n 8 Botswana Africa     1977    59.3 781472     3215.\n 9 Botswana Africa     1982    61.5 970347     4551.\n10 Comoros  Africa     1997    60.7 527982     1174.\n# ℹ 78 more rows"
  },
  {
    "objectID": "content/slides/02-02-filter.html#filter-rows-with-filter-3",
    "href": "content/slides/02-02-filter.html#filter-rows-with-filter-3",
    "title": "Filtering Your Data",
    "section": "Filter rows with filter()",
    "text": "Filter rows with filter()\n\nfilter(gapminder, pop &gt; 500000 | pop &lt; 1000000)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-02-filter.html#handy-operations",
    "href": "content/slides/02-02-filter.html#handy-operations",
    "title": "Filtering Your Data",
    "section": "Handy operations",
    "text": "Handy operations\n== is equal to\n\n!= is not equal to\n\n&gt;= is greater than or equal to\n\n&lt;= is less than or equal to"
  },
  {
    "objectID": "content/slides/02-02-filter.html#handy-operations-1",
    "href": "content/slides/02-02-filter.html#handy-operations-1",
    "title": "Filtering Your Data",
    "section": "Handy operations",
    "text": "Handy operations\n\n| is OR\n\n& is AND\n\n%in% is in"
  },
  {
    "objectID": "content/slides/02-03-arrange.html#arrange-rows-with-arrange",
    "href": "content/slides/02-03-arrange.html#arrange-rows-with-arrange",
    "title": "Sorting Your Data",
    "section": "Arrange rows with arrange()",
    "text": "Arrange rows with arrange()\n\narrange(gapminder, country, year)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-03-arrange.html#arrange-rows-with-arrange-1",
    "href": "content/slides/02-03-arrange.html#arrange-rows-with-arrange-1",
    "title": "Sorting Your Data",
    "section": "Arrange rows with arrange()",
    "text": "Arrange rows with arrange()\n\narrange(gapminder, country, desc(year))\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       2007    43.8 31889923      975.\n 2 Afghanistan Asia       2002    42.1 25268405      727.\n 3 Afghanistan Asia       1997    41.8 22227415      635.\n 4 Afghanistan Asia       1992    41.7 16317921      649.\n 5 Afghanistan Asia       1987    40.8 13867957      852.\n 6 Afghanistan Asia       1982    39.9 12881816      978.\n 7 Afghanistan Asia       1977    38.4 14880372      786.\n 8 Afghanistan Asia       1972    36.1 13079460      740.\n 9 Afghanistan Asia       1967    34.0 11537966      836.\n10 Afghanistan Asia       1962    32.0 10267083      853.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-03-arrange.html#get-the-smallest-or-largest-value-in-one-line-of-code",
    "href": "content/slides/02-03-arrange.html#get-the-smallest-or-largest-value-in-one-line-of-code",
    "title": "Sorting Your Data",
    "section": "Get the smallest or largest value in one line of code",
    "text": "Get the smallest or largest value in one line of code\n\nslice_min(gapminder, lifeExp)\n\n# A tibble: 1 × 6\n  country continent  year lifeExp     pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n1 Rwanda  Africa     1992    23.6 7290203      737.\n\n\n\n\nslice_max(gapminder, lifeExp)\n\n# A tibble: 1 × 6\n  country continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Japan   Asia       2007    82.6 127467972    31656."
  },
  {
    "objectID": "content/slides/02-04-select.html#select-columns-with-select",
    "href": "content/slides/02-04-select.html#select-columns-with-select",
    "title": "Selecting Relevant Columns",
    "section": "Select columns with select()",
    "text": "Select columns with select()\n\nselect(gapminder, country, year, pop)\n\n# A tibble: 1,704 × 3\n   country      year      pop\n   &lt;fct&gt;       &lt;int&gt;    &lt;int&gt;\n 1 Afghanistan  1952  8425333\n 2 Afghanistan  1957  9240934\n 3 Afghanistan  1962 10267083\n 4 Afghanistan  1967 11537966\n 5 Afghanistan  1972 13079460\n 6 Afghanistan  1977 14880372\n 7 Afghanistan  1982 12881816\n 8 Afghanistan  1987 13867957\n 9 Afghanistan  1992 16317921\n10 Afghanistan  1997 22227415\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-04-select.html#select-columns-with-select-1",
    "href": "content/slides/02-04-select.html#select-columns-with-select-1",
    "title": "Selecting Relevant Columns",
    "section": "Select columns with select()",
    "text": "Select columns with select()\n\nselect(gapminder, country:pop)\n\n# A tibble: 1,704 × 5\n   country     continent  year lifeExp      pop\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;\n 1 Afghanistan Asia       1952    28.8  8425333\n 2 Afghanistan Asia       1957    30.3  9240934\n 3 Afghanistan Asia       1962    32.0 10267083\n 4 Afghanistan Asia       1967    34.0 11537966\n 5 Afghanistan Asia       1972    36.1 13079460\n 6 Afghanistan Asia       1977    38.4 14880372\n 7 Afghanistan Asia       1982    39.9 12881816\n 8 Afghanistan Asia       1987    40.8 13867957\n 9 Afghanistan Asia       1992    41.7 16317921\n10 Afghanistan Asia       1997    41.8 22227415\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-04-select.html#select-columns-with-select-2",
    "href": "content/slides/02-04-select.html#select-columns-with-select-2",
    "title": "Selecting Relevant Columns",
    "section": "Select columns with select()",
    "text": "Select columns with select()\n\nselect(gapminder, -(lifeExp:pop))\n\n# A tibble: 1,704 × 4\n   country     continent  year gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952      779.\n 2 Afghanistan Asia       1957      821.\n 3 Afghanistan Asia       1962      853.\n 4 Afghanistan Asia       1967      836.\n 5 Afghanistan Asia       1972      740.\n 6 Afghanistan Asia       1977      786.\n 7 Afghanistan Asia       1982      978.\n 8 Afghanistan Asia       1987      852.\n 9 Afghanistan Asia       1992      649.\n10 Afghanistan Asia       1997      635.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-05-mutate.html#add-new-variables-with-mutate",
    "href": "content/slides/02-05-mutate.html#add-new-variables-with-mutate",
    "title": "Creating or changing columns of data",
    "section": "Add new variables with mutate()",
    "text": "Add new variables with mutate()\n\nmutate(gapminder, gdp = gdpPercap * pop)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-05-mutate.html#change-existing-columns",
    "href": "content/slides/02-05-mutate.html#change-existing-columns",
    "title": "Creating or changing columns of data",
    "section": "Change existing columns",
    "text": "Change existing columns\n\nmutate(gapminder, gdpPercap = log(gdpPercap))\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      6.66\n 2 Afghanistan Asia       1957    30.3  9240934      6.71\n 3 Afghanistan Asia       1962    32.0 10267083      6.75\n 4 Afghanistan Asia       1967    34.0 11537966      6.73\n 5 Afghanistan Asia       1972    36.1 13079460      6.61\n 6 Afghanistan Asia       1977    38.4 14880372      6.67\n 7 Afghanistan Asia       1982    39.9 12881816      6.89\n 8 Afghanistan Asia       1987    40.8 13867957      6.75\n 9 Afghanistan Asia       1992    41.7 16317921      6.48\n10 Afghanistan Asia       1997    41.8 22227415      6.45\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-05-mutate.html#select-transform-and-add-new-variables-with-transmute",
    "href": "content/slides/02-05-mutate.html#select-transform-and-add-new-variables-with-transmute",
    "title": "Creating or changing columns of data",
    "section": "Select, transform, and add new variables with transmute()",
    "text": "Select, transform, and add new variables with transmute()\n\ntransmute(gapminder, country, year, gdp = gdpPercap * pop)\n\n# A tibble: 1,704 × 3\n   country      year          gdp\n   &lt;fct&gt;       &lt;int&gt;        &lt;dbl&gt;\n 1 Afghanistan  1952  6567086330.\n 2 Afghanistan  1957  7585448670.\n 3 Afghanistan  1962  8758855797.\n 4 Afghanistan  1967  9648014150.\n 5 Afghanistan  1972  9678553274.\n 6 Afghanistan  1977 11697659231.\n 7 Afghanistan  1982 12598563401.\n 8 Afghanistan  1987 11820990309.\n 9 Afghanistan  1992 10595901589.\n10 Afghanistan  1997 14121995875.\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "content/slides/02-06-summarise.html#create-summaries-with-summarise",
    "href": "content/slides/02-06-summarise.html#create-summaries-with-summarise",
    "title": "Summarising your data",
    "section": "Create summaries with summarise()",
    "text": "Create summaries with summarise()\n\nsummarise(\n  gapminder, avg_pop = mean(pop), avg_gdp_per_cap = mean(gdpPercap)\n)\n\n# A tibble: 1 × 2\n    avg_pop avg_gdp_per_cap\n      &lt;dbl&gt;           &lt;dbl&gt;\n1 29601212.           7215."
  },
  {
    "objectID": "content/slides/02-06-summarise.html#create-summaries-with-summarise-1",
    "href": "content/slides/02-06-summarise.html#create-summaries-with-summarise-1",
    "title": "Summarising your data",
    "section": "Create summaries with summarise()",
    "text": "Create summaries with summarise()\n\nsummarise(\n  gapminder, \n  avg_pop = mean(pop), \n  median_pop = median(pop), \n  avg_gdp_per_cap = mean(gdpPercap),\n  median_gdp_per_cap = median(gdpPercap)\n)\n\n# A tibble: 1 × 4\n    avg_pop median_pop avg_gdp_per_cap median_gdp_per_cap\n      &lt;dbl&gt;      &lt;dbl&gt;           &lt;dbl&gt;              &lt;dbl&gt;\n1 29601212.   7023596.           7215.              3532."
  },
  {
    "objectID": "content/slides/02-06-summarise.html#creating-grouped-summaries-with-group_by-and-summarise",
    "href": "content/slides/02-06-summarise.html#creating-grouped-summaries-with-group_by-and-summarise",
    "title": "Summarising your data",
    "section": "Creating grouped summaries with group_by() and summarise()",
    "text": "Creating grouped summaries with group_by() and summarise()\n\ngapminder_continent &lt;- group_by(gapminder, continent)\n\nsummarise(\n  gapminder_continent, \n  avg_pop = mean(pop), \n  avg_gdp_per_cap = mean(gdpPercap)\n)\n\n# A tibble: 5 × 3\n  continent   avg_pop avg_gdp_per_cap\n  &lt;fct&gt;         &lt;dbl&gt;           &lt;dbl&gt;\n1 Africa     9916003.           2194.\n2 Americas  24504795.           7136.\n3 Asia      77038722.           7902.\n4 Europe    17169765.          14469.\n5 Oceania    8874672.          18622."
  },
  {
    "objectID": "content/slides/02-07-pipe.html#combine-multiple-operations-with-the-pipe",
    "href": "content/slides/02-07-pipe.html#combine-multiple-operations-with-the-pipe",
    "title": "The pipe",
    "section": "Combine multiple operations with the pipe",
    "text": "Combine multiple operations with the pipe\nThat got messy!\n\nWe had a lot of different objects representing intermediate steps in our calculations.\nWe never need those objects again. Can we avoid creating them?\n\nLet’s introduce perhaps the defining feature of the tidyverse: the pipe."
  },
  {
    "objectID": "content/slides/02-07-pipe.html#combine-multiple-operations-with-the-pipe-1",
    "href": "content/slides/02-07-pipe.html#combine-multiple-operations-with-the-pipe-1",
    "title": "The pipe",
    "section": "Combine multiple operations with the pipe",
    "text": "Combine multiple operations with the pipe\nRead the pipe as:\nTake this |&gt; (and then…)      do this |&gt; (and then…)      do this\n\ngapminder |&gt; \n  group_by(continent) |&gt; \n  summarise(avg_pop = mean(pop), avg_gdp_per_cap = mean(gdpPercap)) |&gt; \n  arrange(avg_gdp_per_cap)\n\n# A tibble: 5 × 3\n  continent   avg_pop avg_gdp_per_cap\n  &lt;fct&gt;         &lt;dbl&gt;           &lt;dbl&gt;\n1 Africa     9916003.           2194.\n2 Americas  24504795.           7136.\n3 Asia      77038722.           7902.\n4 Europe    17169765.          14469.\n5 Oceania    8874672.          18622."
  },
  {
    "objectID": "content/slides/02-07-pipe.html#combine-multiple-operations-with-the-pipe-2",
    "href": "content/slides/02-07-pipe.html#combine-multiple-operations-with-the-pipe-2",
    "title": "The pipe",
    "section": "Combine multiple operations with the pipe",
    "text": "Combine multiple operations with the pipe\n\ngapminder |&gt; \n  group_by(continent) |&gt; \n  summarise(avg_pop = mean(pop), avg_gdp_per_cap = mean(gdpPercap)) |&gt; \n  ggplot(aes(x = continent, y = avg_gdp_per_cap)) + \n  geom_col() + \n  theme_minimal()"
  },
  {
    "objectID": "content/slides/02-07-pipe.html#a-note-on-the-pipe",
    "href": "content/slides/02-07-pipe.html#a-note-on-the-pipe",
    "title": "The pipe",
    "section": "A note on the pipe",
    "text": "A note on the pipe\n\n\nBase pipe:\n\n|&gt;\nCan be used without loading any packages\nRelatively new: introduced in 2021\n\n\nTidyverse pipe:\n\n%&gt;%\nMust load dplyr or magrittr to use"
  },
  {
    "objectID": "content/slides/02-07-pipe.html#summary",
    "href": "content/slides/02-07-pipe.html#summary",
    "title": "The pipe",
    "section": "Summary",
    "text": "Summary\nThis session you have:\n\nLearnt R basic syntax\nLearnt how to transform your data\nWritten concise code that is easy to follow"
  },
  {
    "objectID": "content/04-02-linear_regression.html",
    "href": "content/04-02-linear_regression.html",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "",
    "text": "Generally, we - political scientists - want to understand what factors shape important political outcomes. We can use empirical research to help build and bolster this understanding. Many of the questions we ask cannot be answered using experiments. We are left, instead, to look back at the history of our outcome of interest (for example, global conflicts, democratic backsliding, elections), and attempt to tease out the role various factors played in shaping those outcomes. This section focuses on developing your ability to do this."
  },
  {
    "objectID": "content/04-02-linear_regression.html#set-up",
    "href": "content/04-02-linear_regression.html#set-up",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "Set up",
    "text": "Set up\nTo complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(c(\"marginaleffects\", \"janitor\", \"ggdist\"))\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(modelsummary)\nlibrary(marginaleffects)\nlibrary(janitor)\nlibrary(ggdist)\nlibrary(polisciols)"
  },
  {
    "objectID": "content/04-02-linear_regression.html#introduction",
    "href": "content/04-02-linear_regression.html#introduction",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "Introduction",
    "text": "Introduction\nSpecifically, this section develops your ability to estimate average treatment effects using observational data."
  },
  {
    "objectID": "content/04-02-linear_regression.html#the-economic-benefits-of-justice",
    "href": "content/04-02-linear_regression.html#the-economic-benefits-of-justice",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "The economic benefits of justice",
    "text": "The economic benefits of justice\nAppel and Loyle (2012) (two wonderful UMD alumni) explore the determinants of foreign direct investment (FDI) flows into and out of post-conflict states. States that are emerging from civil war often have an acute need for foreign and stable sources of capital. However, multinational corporations and other foreign commercial actors are likely to view post-conflict states as high risk countries in which to invest: the risk of a return to violence and instability is often high in the immediate aftermath of a civil war. Understanding this, leaders of post-conflict states often attempt to decrease this perceived risk.\nAppel and Loyle argue that leaders can successfully do this by establishing post-conflict justice (PCJ) institutions. These institutions impose both domestic and reputational costs on post-conflict leaders. These costs allow leaders to signal their commitment to minimizing the risk of a return to violence and instability to foreign commercial actors. This is a great paper and I highly encourage you to take a look at their argument in detail.\nTheir argument focuses on leaders’ attempts to change foreign commercial actors’ perceptions of the risk of a return to violence. We cannot directly observe these commercial actors’ perceptions. However, we can observe the outcome of these perceptions: investment. If Appel and Loyle’s argument is correct, we should observe higher levels of FDI investment coming into post-conflict states that establish PCJ institutions compared to those that do not, on average and holding all else constant.\nAppel and Loyle find strong evidence of this. We will replicate and modify this empirical work. In doing so, we will become more familiar with the underlying mechanics of multiple linear regression and strengthen our ability to interpret these models.\nLet’s get started!"
  },
  {
    "objectID": "content/04-02-linear_regression.html#net-fdi-inflows-to-post-conflict-states",
    "href": "content/04-02-linear_regression.html#net-fdi-inflows-to-post-conflict-states",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "Net FDI inflows to post-conflict states",
    "text": "Net FDI inflows to post-conflict states\nAppel and Loyle provide us with data on 95 different post-conflict states. These include all states that had internal armed conflicts, including internationalized conflicts, that resulted in at least 25 battle-related deaths and were settled between 1970 and 2001.\nWe can access these data through polisciols::ebj:\n\nhead(ebj)\n\n   id ccode      country_name              pcj net_fdi_inflows gdp_per_capita\n1  71    41             Haiti  No institutions         -9.8000       1182.498\n2  71    41             Haiti  No institutions          6.6000       1088.680\n3 154    52 Trinidad & Tobago  No institutions        510.1589       7742.736\n4 102    70            Mexico  No institutions       -340.6904       6894.704\n5 102    70            Mexico  No institutions       6460.7998       7780.053\n6  67    90         Guatemala PCJ institutions        431.3800       3061.873\n           gdp gdp_per_capita_growth ex_rate_fluc cap_account_openness labor\n1   8407079981            -2.1324685     0.000000           -0.7681904  68.5\n2   8055393763           -14.8832922     1.776603           -0.0871520  67.9\n3   9542938026             1.9370972     0.000000           -1.1305820  55.2\n4 628418000000            -7.8634830     1.978028            1.1804080  59.8\n5 730752000000             5.2345648     1.129686            1.1804080  61.3\n6  31339424077             0.6277104     1.046489            1.2642760  63.1\n  f_life_exp polity2 pol_constraints conflict_duration     damage\n1   55.02233       7            0.00                 1   0.000000\n2   56.09750      -7            0.00                 1  12.855902\n3   72.61483       9            0.84                 1  -2.787351\n4   74.67104       4            0.39                 1   0.000000\n5   75.23493       6            0.39                 1  -8.949999\n6   67.46067       8            0.43                31 -43.714600\n  peace_agreement    victory      cold_war\n1    No agreement    Victory Post-Cold War\n2    No agreement    Victory Post-Cold War\n3    No agreement    Victory Post-Cold War\n4 Peace agreement No victory Post-Cold War\n5    No agreement No victory Post-Cold War\n6 Peace agreement No victory Post-Cold War\n\n\nThey focus on the 10-year period immediately following the conflict’s conclusion. This is the period in which we would expect foreign commercial actors to perceive the risk of a return to violence and instability to be greatest and, therefore, the period in which leaders’ attempts to quash these perceptions to be most relevant.\nTherefore, each row in this data set represents a single post-conflict state. The data is generally a summary of the 10-years post-conflict. For example net_fdi_inflows provides us with the total net FDI inflows each post-conflict state received in that 10-year period.\n\n\n\n\n\n\nTip\n\n\n\nYou can learn more about each variable using the following command:\n\n?ebj\n\n\n\nTheir outcome of interest is net FDI inflows. Remember, if their argument is correct we would expect post-conflict states that have established a PCJ institution to have higher net FDI inflows than than states that did not. Let’s take a look at those net inflows:\n\nsummary(ebj$net_fdi_inflows)\n\n     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. \n-1858.914    -0.572    38.290   759.146   408.250 24836.787 \n\n\n\nggplot(ebj, aes(x = net_fdi_inflows)) + \n  geom_histogram() + \n  theme_minimal() + \n  scale_x_continuous(labels = scales::dollar)\n\n\n\n\n\n\n\nThere appears to be a clear outlier: a net FDI inflow of $24,836.79 million for Russia. You can see that this is pulling up the average net FDI inflows well above the median inflow across our group of post-conflict states. We will keep this in because this is not the focus of this session, but I would encourage you to explore whether these findings are sensitive to its inclusion.\nWe learn from this that some states have greater FDI outflows than inflows (resulting in negative net FDI inflows). Indonesia had the greatest negative inflow, with net inflows of -$1,858.91 million.\nOther states received greater foreign investments than they invested elsewhere, resulting in positive net FDI inflows. In fact, on average, post-conflict states received more inflows than outflows."
  },
  {
    "objectID": "content/04-02-linear_regression.html#pcj-institutions",
    "href": "content/04-02-linear_regression.html#pcj-institutions",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "PCJ institutions",
    "text": "PCJ institutions\nAppel and Loyle focus on whether states that have PCJ institutions successfully attract greater net FDI inflows than those that do not. Therefore, their main explanatory variable is the existance of PCJ institutions.\nThis variable, pcj, indicates whether the the state established a PCJ institution within five years following the end of the conflict. What proportion of states did this?\n\ntabyl(ebj, pcj)\n\n              pcj  n   percent\n  No institutions 77 0.8105263\n PCJ institutions 18 0.1894737\n\n\nThe majority of post-conflict states did not have PCJ institutions."
  },
  {
    "objectID": "content/04-02-linear_regression.html#relationship-between-pcj-institutions-and-net-fdi-inflows",
    "href": "content/04-02-linear_regression.html#relationship-between-pcj-institutions-and-net-fdi-inflows",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "Relationship between PCJ institutions and net FDI inflows",
    "text": "Relationship between PCJ institutions and net FDI inflows\nOf the states that do have a PCJ institution, do they tend to receive higher net FDI inflows than their less reconciliatory counterparts?\n\nebj |&gt; \n  group_by(pcj) |&gt; \n  summarise(avg_net_fdi = mean(net_fdi_inflows))\n\n# A tibble: 2 × 2\n  pcj              avg_net_fdi\n  &lt;fct&gt;                  &lt;dbl&gt;\n1 No institutions         425.\n2 PCJ institutions       2189.\n\n\nYes! States that established a PCJ institution received higher net FDI inflows, on average, than those states that did not. This difference looks large! It’s $1,763.52 million in net inflows!\nBut what are the chances this difference is simply the product of chance? We can formally test this question using linear regression:\n\nm &lt;- lm(net_fdi_inflows ~ pcj, data = ebj)\n\nmodelsummary(m, \n             coef_rename = c(\"pcjPCJ institutions\" = \"PCJ institutions established\"),\n             stars = T)\n\n\n\n    \n\n      \n\n \n                (1)\n              \n+ p \n\n\n(Intercept)                 \n                  425.006  \n                \n\n                            \n                  (323.874)\n                \n\nPCJ institutions established\n                  1763.517*\n                \n\n                            \n                  (744.049)\n                \n\nNum.Obs.                    \n                  95       \n                \n\nR2                          \n                  0.057    \n                \n\nR2 Adj.                     \n                  0.047    \n                \n\nAIC                         \n                  1784.5   \n                \n\nBIC                         \n                  1792.2   \n                \n\nLog.Lik.                    \n                  -889.253 \n                \n\nRMSE                        \n                  2811.91  \n                \n\n\n\n\n\n\nAccording to this model, what is the average predicted net FDI inflows for countries that did not establish PCJ institution?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nPost-conflict states that did not establish a PCJ institution received, on average, net FDI inflows of $425.01 million in the 10-year period after conflict.\nTo get this, I looked at the intercept coefficient which tells us the average predicted value of our outcome variable when all explanatory variables are equal to zero or their baseline category.\n\n\n\nAccording to this model, what is the average predicted net FDI inflows for countries that did establish PCJ institution?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nIn contrast, states that did establish PCJ institution received, on average, net FDI inflows of $2,188.52 million.\nIn other words:\n\\[\nAverage\\ net\\ FDI\\ inflows = \\beta_0 + \\beta_1 Institution\\ established + \\epsilon\n\\]\nWhen an institution was established (i.e. \\(Institution\\ established = 1\\)):\n\\[\nAverage\\ net\\ FDI\\ inflows = 425.01 + 1763.52 * 1 + \\epsilon \\\\\n\\]\n\\[\nAverage\\ net\\ FDI\\ inflows = 2188.52\n\\]\n\n\n\nSubstantive significance\nThis finding is substantively significant. These countries are recovering from conflict: their economies are really weak. Leaders are often very keen to find stable and reliable sources of funding to promote and strengthen their battered economies. This average difference of $1,763.52 million is; therefore, likely to incentivize this policy.\nFurther, if we look at the range of plausible values of the coefficient on the existence of a PCJ institution (i.e. the confidence interval) we can see states that did not establish a commission plausibly receive no net FDI inflows in this post-conflict period. In fact, it is plausible that investment leaves their economies: this net inflow can be negative. On the other hand, states that do establish a commission enjoy, on average, billions in net FDI inflows. For an economy struggling to establish indigenous production in a post-conflict setting, this can be critical to their long-term economic development. Again, this is further proof of the substantive significance of this relationship.\n\n\n\n\n\n\nTip\n\n\n\nVisualizing the full range of plausible coefficients can be a great way to communicate your findings:\n\nplot_predictions(m, condition = \"pcj\") + \n  geom_hline(yintercept = 0, colour = \"grey\") + \n  labs(x = NULL,\n       y = \"Net FDI inflows (USD million)\") + \n  scale_y_continuous(labels = scales::dollar) + \n  theme_minimal()"
  },
  {
    "objectID": "content/04-02-linear_regression.html#but-what-about-other-factors-that-shape-net-fdi-inflows",
    "href": "content/04-02-linear_regression.html#but-what-about-other-factors-that-shape-net-fdi-inflows",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "But what about other factors that shape net FDI inflows?",
    "text": "But what about other factors that shape net FDI inflows?\nOne of Appel and Loyle’s major contributions is their critique of approaches to estimating net FDI inflows that focus only on economic factors. They argue that there are several political factors that are significant determinants of other countries’ and foreign firms’ willingness to invest in these war-torn countries.\nThis critique is very valid, but it suggests that there are many different things influencing this outcome of interest, including economic factors. We have only looked at the political! The economists might turn around and accuse us of doing the very thing Appel and Loyle accused them of!\nLet’s add some of those economic factors into our model. We will start with an intuitive one: individuals’ economic wealth (measured as GDP per capita). I expect that foreign firms will be more willing to invest larger sums of money into economies with richer citizens. These citizens will be more willing and able to purchase the goods and services provided by those firms.\nTherefore, I hypothesize that the greater a state’s GDP per capita, the larger its net FDI inflows. I expect this to be the case regardless of whether the state has established a PCJ institution. Let’s test this claim:\n\nm &lt;- lm(net_fdi_inflows ~ pcj + gdp_per_capita, data = ebj)\n\nmodelsummary(m, \n             coef_rename = c(\"pcjPCJ institutions\" = \"PCJ institutions established\",\n                             \"gdp_per_capita\" = \"GDP per capita (current USD)\"),\n             stars = T)\n\n\n\n    \n\n      \n\n \n                (1)\n              \n+ p \n\n\n(Intercept)                 \n                  -319.173 \n                \n\n                            \n                  (396.052)\n                \n\nPCJ institutions established\n                  1673.288*\n                \n\n                            \n                  (714.015)\n                \n\nGDP per capita (current USD)\n                  0.318**  \n                \n\n                            \n                  (0.105)  \n                \n\nNum.Obs.                    \n                  95       \n                \n\nR2                          \n                  0.142    \n                \n\nR2 Adj.                     \n                  0.124    \n                \n\nAIC                         \n                  1777.5   \n                \n\nBIC                         \n                  1787.7   \n                \n\nLog.Lik.                    \n                  -884.742 \n                \n\nRMSE                        \n                  2681.52  \n                \n\n\n\n\n\n\nWe continue to find a positive and statistically significant relationship between net FDI inflows and the establishment of a PCJ institution. This model also accounts for the association between the state’s GDP per capita and those inflows.\nThe intercept here is not informative on its own. It tells us the estimated average net FDI inflows for states that do not have PCJ institutions and in which citizens had a GDP per capita of $0. Although the majority of states did not establish an institution, there are no states in the world that have a GDP per capita of $0.\nLet’s instead focus on the other coefficients. We find that states that established a PCJ institution received, on average, net FDI inflows of $1,673.29 million more than states that did not in the 10-year period after conflict. This is a slightly smaller estimated difference than we found in the model that did not account for individuals’ average wealth, but it remains large.\nWe also find that an increase in the GDP per capita of a state of $1,000 is associated with an increase of $318.45 million in net FDI inflow. This is consistent with our expectations that, holding all else constant, a country with a richer population is a more attractive investment destination than a country that has poorer citizens.\nUsing this richer model\nWe now have a richer understanding of the determinants of net FDI inflows to post-conflict countries. We have accounted for both economic and political determinants of those flows. Although it is often useful to look at the estimated relationship of each of those variables individually (as we did just above), we often learn more by looking at the whole model in context.\nAs usual, one of the easiest ways to communicate this is through a visualization. Let’s look at the predicted net FDI inflows for post-conflict countries that established and did not establish PCJ institutions across a range of plausible GDP per capita values:\n\nplot_predictions(m, condition = c(\"gdp_per_capita\", \"pcj\")) + \n  labs(x = \"GDP per capita (USD)\",\n       y = \"Net FDI inflows (USD million)\") + \n  scale_y_continuous(labels = scales::dollar) + \n  scale_x_continuous(labels = scales::dollar) + \n  theme_minimal()\n\n\n\n\n\n\n\nWe can see the positive relationship between GDP per capita and net FDI inflows and that across any given value of GDP per capita states that have established a PCJ institution start and stay at a higher predicted inflow compared to those that did not.\nThe full model\nAppel and Loyle control for many more economic and political factors shaping net FDI inflows. Remember, they are arguing that the extensive literature that looks at the determinants of FDI flows to post-conflict states failed to account for this important political factor. However, that same literature did a very good job of identifying the economic factors, including countries’ economic development, size, and growth rates, that shape this outcome. They don’t dispute that these factors are also important, they just argue that we should also think about the role PCJ institutions play in shaping foreign firms’ beliefs about the risk of returning to violence.\nSo, let’s account for these other factors:\n\nm &lt;- lm(net_fdi_inflows ~ pcj + gdp_per_capita + gdp + gdp_per_capita_growth + \n          cap_account_openness + ex_rate_fluc + labor + f_life_exp + \n          pol_constraints + polity2 + damage + conflict_duration + peace_agreement + \n          victory + cold_war, \n        data = ebj)\n\nmodelsummary(m, \n             coef_rename = c(\"pcjPCJ institutions\" = \"PCJ institutions established\",\n                             \"gdp_per_capita\" = \"GDP per capita (current USD)\",\n                             \"gdp\" = \"GDP (current USD)\",\n                             \"gdp_per_capita_growth\" = \"GDP per capita growth rate (%)\",\n                             \"cap_account_openness\" = \"Capital account openness\",\n                             \"ex_rate_fluc\" = \"Exchange rate fluctuation\",\n                             \"labor\" = \"Labor force participation (%)\",\n                             \"f_life_exp\" = \"Average female life expectancy (years)\",\n                             \"pol_constraints\" = \"Political constraints\",\n                             \"polity2\" = \"Regime type (Polity score)\",\n                             \"damage\" = \"Pre-conflict GDP lost\",\n                             \"conflict_duration\" = \"Conflict duration (years)\",\n                             \"peace_agreementPeace agreement\" = \"Peace agreement\",\n                             \"victoryVictory\" = \"Decisive victory\",\n                             \"cold_warCold War\" = \"Cold War\"),\n             stars = T)\n\n\n\n    \n\n      \n\n \n                (1)\n              \n+ p \n\n\n(Intercept)                           \n                  -1278.322 \n                \n\n                                      \n                  (2852.294)\n                \n\nPCJ institutions established          \n                  1960.282**\n                \n\n                                      \n                  (702.992) \n                \n\nGDP per capita (current USD)          \n                  -0.111    \n                \n\n                                      \n                  (0.133)   \n                \n\nGDP (current USD)                     \n                  0.000***  \n                \n\n                                      \n                  (0.000)   \n                \n\nGDP per capita growth rate (%)        \n                  37.400    \n                \n\n                                      \n                  (23.239)  \n                \n\nCapital account openness              \n                  198.823   \n                \n\n                                      \n                  (201.590) \n                \n\nExchange rate fluctuation             \n                  -42.516** \n                \n\n                                      \n                  (13.888)  \n                \n\nLabor force participation (%)         \n                  9.844     \n                \n\n                                      \n                  (25.528)  \n                \n\nAverage female life expectancy (years)\n                  3.475     \n                \n\n                                      \n                  (32.993)  \n                \n\nPolitical constraints                 \n                  2557.954+ \n                \n\n                                      \n                  (1459.599)\n                \n\nRegime type (Polity score)            \n                  -90.169   \n                \n\n                                      \n                  (56.309)  \n                \n\nPre-conflict GDP lost                 \n                  28.379**  \n                \n\n                                      \n                  (10.242)  \n                \n\nConflict duration (years)             \n                  0.811     \n                \n\n                                      \n                  (35.543)  \n                \n\nPeace agreement                       \n                  -1215.137 \n                \n\n                                      \n                  (793.826) \n                \n\nDecisive victory                      \n                  -33.969   \n                \n\n                                      \n                  (650.725) \n                \n\nCold War                              \n                  81.531    \n                \n\n                                      \n                  (654.092) \n                \n\nNum.Obs.                              \n                  95        \n                \n\nR2                                    \n                  0.514     \n                \n\nR2 Adj.                               \n                  0.422     \n                \n\nAIC                                   \n                  1749.5    \n                \n\nBIC                                   \n                  1792.9    \n                \n\nLog.Lik.                              \n                  -857.752  \n                \n\nRMSE                                  \n                  2018.34   \n                \n\n\n\n\n\n\nEven when we account for all the political, economic, and conflict-related factors that the literature previously identified to be important, we still find that the existence of PCJ institution substantively and statistically significantly shapes the net FDI inflows of post-conflict states."
  },
  {
    "objectID": "content/04-02-linear_regression.html#including-categorical-variables-with-multiple-categories",
    "href": "content/04-02-linear_regression.html#including-categorical-variables-with-multiple-categories",
    "title": "Estimating Causal Effects with Observational Data",
    "section": "Including categorical variables with multiple categories",
    "text": "Including categorical variables with multiple categories\nAppel and Loyle look at a number of political factors driving net FDI inflows to post-conflict states. They include a measure of regime type: the country’s Polity score. This score measures a state’s regime type along a 21-point scale from -10 (perfect autocracy) to 10 (perfect democracy). Broadly speaking, political scientists have usefully broken this spectrum down into three regime types: democracies, hybrid regimes, and autocracies.\nLet’s modify their measure of regime type to reflect these broad categories, instead of treating it as a continuous variable:\n\nebj &lt;- ebj |&gt; \n  mutate(regime_type = case_when(polity2 &gt; 5 ~ \"Democracy\",\n                                 polity2 &lt; -5 ~ \"Autocracy\",\n                                 TRUE ~ \"Hybrid regime\"),\n         regime_type = factor(regime_type, levels = c(\"Autocracy\",\n                                                      \"Hybrid regime\",\n                                                      \"Democracy\")))\n\nI have a theoretical reason to do this. I suspect that there is not a clear linear relationship between investors’ confidence in a post-conflict state and its regime type when we treat regime type as a continuous spectrum moving linearly from autocracies to democracies. In other words, I don’t think that moving one Polity score away from being an autocracy to being a democracy would have a consistent effect on investor confidence (and; therefore, net FDI inflows). Appel and Loyle’s model agrees with me: the regime type variable is not statistically significant.\nRather, I suspect that strong democracies and strong autocracies provide the political stability required to comfort foreign investors. These investors believe that the strong control democrats and autocrats have over their citizens and institutions reduces the risk that the country will re-enter into conflict. However, hybrid regimes do not tend to have this level of control. Investors are; therefore, less likely to invest in post-conflict countries with hybrid regimes.\nLet’s test this!\nWe now have a categorical variable with three categories: democracy, hybrid regime, and autocracy. We have thus far largely dealt with binary categorical variables (voted or not, Southern or not, female or not). How do we use and interpret multiple categorical variables in regression analysis?\nHappily, the intuition remains the same as with our binary categorical variables. We hold one category out as our baseline category and then compare the associated effects of the other categories to this one.\nLet’s step through that using a stripped back version of our model:\n\nm &lt;- lm(net_fdi_inflows ~ pcj + regime_type, data = ebj)\n\nmodelsummary(m, \n             coef_rename = c(\"pcjPCJ institutions\" = \"PCJ institutions established\",\n                             \"regime_typeDemocracy\" = \"Democracy\",\n                             \"regime_typeHybrid regime\" = \"Hybrid\"),\n             stars = T)\n\n\n\n    \n\n      \n\n \n                (1)\n              \n+ p \n\n\n(Intercept)                 \n                  214.555  \n                \n\n                            \n                  (497.984)\n                \n\nPCJ institutions established\n                  1816.169*\n                \n\n                            \n                  (764.093)\n                \n\nHybrid                      \n                  553.893  \n                \n\n                            \n                  (667.644)\n                \n\nDemocracy                   \n                  -148.124 \n                \n\n                            \n                  (809.623)\n                \n\nNum.Obs.                    \n                  95       \n                \n\nR2                          \n                  0.068    \n                \n\nR2 Adj.                     \n                  0.037    \n                \n\nAIC                         \n                  1787.4   \n                \n\nBIC                         \n                  1800.1   \n                \n\nLog.Lik.                    \n                  -888.688 \n                \n\nRMSE                        \n                  2795.25  \n                \n\n\n\n\n\n\nYou’ll note that autocracies are missing from our regression table. This is because they are being held out as our baseline category. Their effect on net FDI inflows is captured by the intercept coefficient.\n\n\n\n\n\n\nTip\n\n\n\nWe often say that the intercept coefficient represents the predicted average value of our outcome of interest when all independent variables are set to zero. It might be useful for you to think of your baseline category as taking on the value zero. For example, we can think of autocracy = 0.\n\n\nOur model suggests that autocracies (regime_type = \"Autocracy\") that have not established a commission (pcj = \"No institutions\") have a predicted average net FDI inflow of $214.55 million.\nThe coefficients on democracies and hybrid regimes need to be interpreted in relation to autocracies (their baseline category). From our model, we can see that the coefficient for democracies is negative and the coefficient for hybrid regimes is positive. That means that, on average, democracies tend to receive less net FDI inflows than autocracies and hybrid regimes tend to receive more net FDI inflows than autocracies.\nPredictions with multiple categorical variables\nUsing our model, what do we predict to be the net FDI inflows for democracies, autocracies, and hybrid regimes that either have a PCJ institutions or do not?\nFirst, let’s create a table with each possible combination of these two variables of interest:\n\nnew_data &lt;- tibble(pcj = factor(c(\"No institutions\", \n                                  \"PCJ institutions\"))) |&gt; \n  cross_join(\n    tibble(regime_type = factor(c(\"Autocracy\", \"Democracy\", \"Hybrid regime\")))\n  )\n\nnew_data\n\n# A tibble: 6 × 2\n  pcj              regime_type  \n  &lt;fct&gt;            &lt;fct&gt;        \n1 No institutions  Autocracy    \n2 No institutions  Democracy    \n3 No institutions  Hybrid regime\n4 PCJ institutions Autocracy    \n5 PCJ institutions Democracy    \n6 PCJ institutions Hybrid regime\n\n\nThen we can use our model to predict what we expect a hypothetical state with each of these combinations of characteristics to receive in net FDI inflows:\n\npred &lt;- augment(m, newdata = new_data)\n\npred\n\n# A tibble: 6 × 3\n  pcj              regime_type   .fitted\n  &lt;fct&gt;            &lt;fct&gt;           &lt;dbl&gt;\n1 No institutions  Autocracy       215. \n2 No institutions  Democracy        66.4\n3 No institutions  Hybrid regime   768. \n4 PCJ institutions Autocracy      2031. \n5 PCJ institutions Democracy      1883. \n6 PCJ institutions Hybrid regime  2585. \n\n\nThat’s a bit unweildy. Let’s visualize it!\n\nggplot(pred, aes(x = .fitted, y = pcj, colour = regime_type)) + \n  geom_point(size = 5) + \n  theme_minimal() + \n  labs(x = \"Predicted net FDI inflows (USD, million)\",\n       y = NULL, \n       colour = \"Regime type\")\n\n\n\n\n\n\n\nWe can clearly see that states that established PCJ institutions received, on average, larger net FDI inflows than states that did not, no matter their regime type. Further and completely counter to my hypothesis, hybrid regimes have, on average, the highest net FDI inflows compared to democracies and autocracies even when we account for whether the state has a PCJ institution.\nI’m not too worried: none of these coefficients are anywhere close to being statistically significant. I suspect that there is a more complex relationship underlying commercial actors’ beliefs about the stability of hybrid regimes, democracies, and autocracies and its effect on net investment flows. But I hope this serves as a good illustration of how we can use multiple categorical variables in our analyses."
  },
  {
    "objectID": "content/03-01-wrangling.html",
    "href": "content/03-01-wrangling.html",
    "title": "Data Wrangling",
    "section": "",
    "text": "To complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(c(\"tidyverse\", \"janitor\", \"scales\", \"wbstats\"))\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(scales)\nlibrary(wbstats)",
    "crumbs": [
      "Content",
      "Session 3",
      "Data Wrangling"
    ]
  },
  {
    "objectID": "content/03-01-wrangling.html#set-up",
    "href": "content/03-01-wrangling.html#set-up",
    "title": "Data Wrangling",
    "section": "",
    "text": "To complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(c(\"tidyverse\", \"janitor\", \"scales\", \"wbstats\"))\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(scales)\nlibrary(wbstats)",
    "crumbs": [
      "Content",
      "Session 3",
      "Data Wrangling"
    ]
  },
  {
    "objectID": "content/03-01-wrangling.html#introduction",
    "href": "content/03-01-wrangling.html#introduction",
    "title": "Data Wrangling",
    "section": "Introduction",
    "text": "Introduction\nI am now going to introduce you to a set of important tools for tidying your data. Oftentimes, the data we want to work with does not come to us in a format that is easy for us to use. We need to wrangle it into a better structure and remove inconsistencies.\nWe will continue to work with the variables the Gapminder Project is interested in: health and wealth. However, instead of accessing the lovely clean data set provided to you in the gapminder R package, we are going to go straight to the source and collect data on countries’ GDP per capita and average life expectancy from the World Bank. Let’s get started!",
    "crumbs": [
      "Content",
      "Session 3",
      "Data Wrangling"
    ]
  },
  {
    "objectID": "content/03-01-wrangling.html#collecting-your-data",
    "href": "content/03-01-wrangling.html#collecting-your-data",
    "title": "Data Wrangling",
    "section": "Collecting your data",
    "text": "Collecting your data\nThe World Bank provides us with access to a trove of official country- and sub-national level data that are very useful for political analysis. I use their data in nearly all of my research. Sadly, they tend to provide their data in a messy format. We will now collect that messy data so we can learn how to tidy it up.\nTo access their data and some wonderful data visualizations, you can head over to their data portal: https://data.worldbank.org/. From there, you can browse which data sets they have or search for ones you are interested in.\nWe are going to start by collecting data on countries’ GDP per capita (current US$). It can be accessed here: https://data.worldbank.org/indicator/NY.GDP.PCAP.CD.\nReading in an external file\nYou can download the data directly from this web page, save it in the appropriate place in your RProject, and read it in from there.\n\n\n\n\n\n\nNote\n\n\n\nThis process is similar to the one we used in Session 2: From Samples to the Population.\n\n\nI saved the CSV in the data folder (which is the in the content folder because this is a website), so I will use here::here() to adaptively find the correct file path and read the file in using read_csv().\n\ngdp_per_cap_raw &lt;- read_csv(here::here(\"content\", \"data\", \n                                       \"API_NY.GDP.PCAP.CD_DS2_en_csv_v2_76.csv\"))\n\nAfter running this yourself, you will see an ominous warning. Let’s take a look at our data:\n\ngdp_per_cap_raw\n\n# A tibble: 268 × 3\n   `Data Source`               `World Development Indicators` ...3              \n   &lt;chr&gt;                       &lt;chr&gt;                          &lt;chr&gt;             \n 1 Last Updated Date           2024-12-16                      &lt;NA&gt;             \n 2 Country Name                Country Code                   \"Indicator Name,I…\n 3 Aruba                       ABW                            \"GDP per capita (…\n 4 Africa Eastern and Southern AFE                            \"GDP per capita (…\n 5 Afghanistan                 AFG                            \"GDP per capita (…\n 6 Africa Western and Central  AFW                            \"GDP per capita (…\n 7 Angola                      AGO                            \"GDP per capita (…\n 8 Albania                     ALB                            \"GDP per capita (…\n 9 Andorra                     AND                            \"GDP per capita (…\n10 Arab World                  ARB                            \"GDP per capita (…\n# ℹ 258 more rows\n\n\nWe have only three columns, none of which appear to have the right names. It also looks like the first few rows may, in fact, not be rows in our data set. Rather, they are metadata, including the last time the data were updated.\nThe second row in our data set looks like the real column headings. This is good! We can skip the first few rows using read_csv()’s skip argument. Just provide it with the number of rows you want to skip when reading in the CSV.\n\ngdp_per_cap_raw &lt;- read_csv(here::here(\"content\", \"data\", \n                                       \"API_NY.GDP.PCAP.CD_DS2_en_csv_v2_76.csv\"),\n                            skip = 3)\n\ngdp_per_cap_raw\n\n# A tibble: 266 × 69\n   `Country Name` `Country Code` `Indicator Name` `Indicator Code` `1960` `1961`\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;            &lt;chr&gt;             &lt;dbl&gt;  &lt;dbl&gt;\n 1 Aruba          ABW            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 2 Africa Easter… AFE            GDP per capita … NY.GDP.PCAP.CD     186.   187.\n 3 Afghanistan    AFG            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 4 Africa Wester… AFW            GDP per capita … NY.GDP.PCAP.CD     122.   127.\n 5 Angola         AGO            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 6 Albania        ALB            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 7 Andorra        AND            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 8 Arab World     ARB            GDP per capita … NY.GDP.PCAP.CD      NA    213.\n 9 United Arab E… ARE            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n10 Argentina      ARG            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n# ℹ 256 more rows\n# ℹ 63 more variables: `1962` &lt;dbl&gt;, `1963` &lt;dbl&gt;, `1964` &lt;dbl&gt;, `1965` &lt;dbl&gt;,\n#   `1966` &lt;dbl&gt;, `1967` &lt;dbl&gt;, `1968` &lt;dbl&gt;, `1969` &lt;dbl&gt;, `1970` &lt;dbl&gt;,\n#   `1971` &lt;dbl&gt;, `1972` &lt;dbl&gt;, `1973` &lt;dbl&gt;, `1974` &lt;dbl&gt;, `1975` &lt;dbl&gt;,\n#   `1976` &lt;dbl&gt;, `1977` &lt;dbl&gt;, `1978` &lt;dbl&gt;, `1979` &lt;dbl&gt;, `1980` &lt;dbl&gt;,\n#   `1981` &lt;dbl&gt;, `1982` &lt;dbl&gt;, `1983` &lt;dbl&gt;, `1984` &lt;dbl&gt;, `1985` &lt;dbl&gt;,\n#   `1986` &lt;dbl&gt;, `1987` &lt;dbl&gt;, `1988` &lt;dbl&gt;, `1989` &lt;dbl&gt;, `1990` &lt;dbl&gt;, …\n\n\nThat looks better! We have now read in the data set itself, skipping those rows of metadata.\nThe resulting data set is a wide one. Each observation is a country or region. The first two columns provide information on the country. The third and fourth describe the indicator. All other columns provide each country’s GDP per capita in all years from 1960 to 2023.\nNow, imagine you want to compare a country’s GDP per capita across many years. For example, you want to know how Australians’ wealth has grown over time. This is very difficult to do with this current format. We would need to work with all columns from 1960 to 2023!\nTo make these data easier to work with, we will lengthen the data set. Instead of each observation (row) describing a country, we will make each observation describe a country-year.\nTo do this, we need to use pivot_longer(). We need to let it know which columns we want to transpose using the col argument. Because the end year for these data will change each year I want to pull and clean up this data set (for example, next year the last column will be 2024, not 2023), I will use ! to negate the columns I don’t want to transpose. This code will, therefore, work after each annual update to the data set.\n\ngdp_per_cap &lt;- gdp_per_cap_raw |&gt; \n  pivot_longer(cols = !c(`Country Name`:`Indicator Code`),\n               names_to = \"year\",\n               values_to = \"gdp_per_cap\")\n\ngdp_per_cap\n\n# A tibble: 17,290 × 6\n   `Country Name` `Country Code` `Indicator Name`         `Indicator Code` year \n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;chr&gt;            &lt;chr&gt;\n 1 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1960 \n 2 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1961 \n 3 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1962 \n 4 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1963 \n 5 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1964 \n 6 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1965 \n 7 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1966 \n 8 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1967 \n 9 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1968 \n10 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1969 \n# ℹ 17,280 more rows\n# ℹ 1 more variable: gdp_per_cap &lt;dbl&gt;\n\n\nI have also told pivot_longer() what to call the column containing the previous column names (using names_to) and the column containing the values (using values_to).\nYou might have noticed that I needed to include some back ticks when referencing those column names. This is because these column names do not follow the rules put in place to help you work with R. Column names must:\n\nNot include spaces\nNot start with numbers or special characters\n\nThey should also be:\n\nShort\nMeaningful\nConsistently formatted\n\nThe World Bank uses spaces in its column names. We need to remove those so we can more easily work with them in R. Happily, the very handy janitor R package is here for all of your cleaning needs!\nI use the clean_names() function to ensure names are clean and consistent:\n\ngdp_per_cap &lt;- clean_names(gdp_per_cap)\ngdp_per_cap\n\n# A tibble: 17,290 × 6\n   country_name country_code indicator_name     indicator_code year  gdp_per_cap\n   &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;              &lt;chr&gt;          &lt;chr&gt;       &lt;dbl&gt;\n 1 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1960           NA\n 2 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1961           NA\n 3 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1962           NA\n 4 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1963           NA\n 5 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1964           NA\n 6 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1965           NA\n 7 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1966           NA\n 8 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1967           NA\n 9 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1968           NA\n10 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1969           NA\n# ℹ 17,280 more rows\n\n\nGreat! We’re almost there. Next, we need to check that R has correctly classified our data types. For example, we want to make sure that the years are coded as numbers not strings of characters.\n\nglimpse(gdp_per_cap)\n\nRows: 17,290\nColumns: 6\n$ country_name   &lt;chr&gt; \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"…\n$ country_code   &lt;chr&gt; \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\",…\n$ indicator_name &lt;chr&gt; \"GDP per capita (current US$)\", \"GDP per capita (curren…\n$ indicator_code &lt;chr&gt; \"NY.GDP.PCAP.CD\", \"NY.GDP.PCAP.CD\", \"NY.GDP.PCAP.CD\", \"…\n$ year           &lt;chr&gt; \"1960\", \"1961\", \"1962\", \"1963\", \"1964\", \"1965\", \"1966\",…\n$ gdp_per_cap    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\n\nHmm, it does appear to have read the years in as characters. Why?\n\nunique(gdp_per_cap$year)\n\n [1] \"1960\"  \"1961\"  \"1962\"  \"1963\"  \"1964\"  \"1965\"  \"1966\"  \"1967\"  \"1968\" \n[10] \"1969\"  \"1970\"  \"1971\"  \"1972\"  \"1973\"  \"1974\"  \"1975\"  \"1976\"  \"1977\" \n[19] \"1978\"  \"1979\"  \"1980\"  \"1981\"  \"1982\"  \"1983\"  \"1984\"  \"1985\"  \"1986\" \n[28] \"1987\"  \"1988\"  \"1989\"  \"1990\"  \"1991\"  \"1992\"  \"1993\"  \"1994\"  \"1995\" \n[37] \"1996\"  \"1997\"  \"1998\"  \"1999\"  \"2000\"  \"2001\"  \"2002\"  \"2003\"  \"2004\" \n[46] \"2005\"  \"2006\"  \"2007\"  \"2008\"  \"2009\"  \"2010\"  \"2011\"  \"2012\"  \"2013\" \n[55] \"2014\"  \"2015\"  \"2016\"  \"2017\"  \"2018\"  \"2019\"  \"2020\"  \"2021\"  \"2022\" \n[64] \"2023\"  \"...69\"\n\n\nLooking at all unique values included in the year column, we can see the culprit: \"...69\". It looks like the CSV includes a rouge last column with no data in it. read_csv() read that column in and coded all its values as NA:\n\ngdp_per_cap |&gt; \n  filter(year == \"...69\") |&gt; \n  distinct(gdp_per_cap)\n\n# A tibble: 1 × 1\n  gdp_per_cap\n        &lt;dbl&gt;\n1          NA\n\n\nWe can simply filter this out of our data set to get rid of it and convert the remaining values to numbers using mutate():\n\ngdp_per_cap &lt;- gdp_per_cap |&gt; \n  filter(year != \"...69\") |&gt; \n  mutate(year = as.numeric(year))\ngdp_per_cap\n\n# A tibble: 17,024 × 6\n   country_name country_code indicator_name     indicator_code  year gdp_per_cap\n   &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;              &lt;chr&gt;          &lt;dbl&gt;       &lt;dbl&gt;\n 1 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1960          NA\n 2 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1961          NA\n 3 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1962          NA\n 4 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1963          NA\n 5 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1964          NA\n 6 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1965          NA\n 7 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1966          NA\n 8 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1967          NA\n 9 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1968          NA\n10 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1969          NA\n# ℹ 17,014 more rows\n\n\nWe now have a nice and clean data set that is easy to work with. Let’s take a look at Australia’s growth over time:\n\ngdp_per_cap |&gt; \n  filter(country_name == \"Australia\") |&gt; \n  ggplot(aes(x = year, y = gdp_per_cap)) + \n  geom_line() + \n  geom_point(size = 1) + \n  theme_minimal() + \n  labs(x = \"Year\",\n       y = \"GDP per capita (current US$)\") + \n  scale_y_continuous(labels = dollar)",
    "crumbs": [
      "Content",
      "Session 3",
      "Data Wrangling"
    ]
  },
  {
    "objectID": "content/02-02-surveys_to_pops.html",
    "href": "content/02-02-surveys_to_pops.html",
    "title": "From Samples to the Population",
    "section": "",
    "text": "A lot the data we use in political science research are incomplete. Rarely do we have data on all actors in our population of interest. We, therefore, need to work out the degree to which our sample of actors resembles what we would see in the population. This session introduces you to the tools you need to do this.",
    "crumbs": [
      "Content",
      "Session 2",
      "From Samples to the Population"
    ]
  },
  {
    "objectID": "content/02-02-surveys_to_pops.html#set-up",
    "href": "content/02-02-surveys_to_pops.html#set-up",
    "title": "From Samples to the Population",
    "section": "Set up",
    "text": "Set up\nTo complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(c(\"tidyverse\", \"wbstats\", \"scales\", \"here\", \"dataverse\"))\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(wbstats)\nlibrary(scales)\nlibrary(here)\nlibrary(dataverse)",
    "crumbs": [
      "Content",
      "Session 2",
      "From Samples to the Population"
    ]
  },
  {
    "objectID": "content/02-02-surveys_to_pops.html#introduction",
    "href": "content/02-02-surveys_to_pops.html#introduction",
    "title": "From Samples to the Population",
    "section": "Introduction",
    "text": "Introduction\n\n\nEntire populations are very difficult to collect data on. Even the census (which aims to account for every citizen living within a country) misses people. Happily, we do not need to learn information about the whole population to discover general trends within it. Instead, we can use good surveys of the population.\nWhat do I mean by “good”? The sample of your population surveyed must be representative of that population. This session focuses on defining what we mean by that.",
    "crumbs": [
      "Content",
      "Session 2",
      "From Samples to the Population"
    ]
  },
  {
    "objectID": "content/02-02-surveys_to_pops.html#representative-samples",
    "href": "content/02-02-surveys_to_pops.html#representative-samples",
    "title": "From Samples to the Population",
    "section": "Representative samples",
    "text": "Representative samples\nSurveys are conducted on a subset of a our population of interest. This is because it is often unfeasible (or impossible) to ask these questions of our population.\nTo be able to infer from our sample information about our population, we need to ensure the sample is representative of that population. In other words, we need to try our best to make sure the sample looks very similar to our population.\nRemember back to the last session on experiments. In an ideal world, we would be able to create two parallel worlds (one with the treatment, one held as our control). These two worlds would be identical to each other prior to treatment. This allows us to confidently state that any differences in our outcome of interest were caused by the treatment. It was, after all, the only thing differentiating those two worlds.\nSadly, however, we have no time machine and cannot produce two parallel worlds. Instead, we needed to create two groups that are as identical to one another as possible prior to treatment. If they are (almost) identical, differences between their group-wide outcomes can be attributed to the treatment.\nOne very good way of getting two (almost) identical groups is to assign individuals to those groups randomly.\n\n\n\n\n\n\nTip\n\n\n\nFor more on why randomization works, please head back to Randomization in Causes and Effects.\n\n\nSimilarly, we can use randomization to pull a sample from our population that looks, on average, identical to that population. Drawing randomly from our population increases our chances of ending up with a sample that reflects that population.",
    "crumbs": [
      "Content",
      "Session 2",
      "From Samples to the Population"
    ]
  },
  {
    "objectID": "content/02-02-surveys_to_pops.html#random-sampling",
    "href": "content/02-02-surveys_to_pops.html#random-sampling",
    "title": "From Samples to the Population",
    "section": "Random sampling",
    "text": "Random sampling\nTo sample randomly from your population, all individuals in the population need to have an equal chance of being selected for the sample. If this holds, you have a pure random sample.\nHowever, this is really hard to do! For example, think about how likely you are to answer a call from an unknown number. Pollsters rely on people picking up their calls. Imagine you do answer: how likely are you to sit through an interview with a pollster?\nThere are groups of people in the US voting population who are more likely to pick up a call from an unknown number. For example, people with land line phones are much more likely to answer that call (they cannot see it is from an unknown number). Similarly, there are groups of people who are more likely to sit through an interview with a pollster. For example, retired people who have the time to spare during their day. These people are systematically different from the population as a whole. People with land land phones tend to be older, on average, than the general population. Similarly, retired people tend to be older than the general population.\nThis is important because older people tend to be more conservative than the general population as well. Your survey (which will include a disproportionately large group of older people) is likely to overstate how conservative the population as a whole is.",
    "crumbs": [
      "Content",
      "Session 2",
      "From Samples to the Population"
    ]
  },
  {
    "objectID": "content/02-02-surveys_to_pops.html#the-effects-of-an-unrepresentative-sample",
    "href": "content/02-02-surveys_to_pops.html#the-effects-of-an-unrepresentative-sample",
    "title": "From Samples to the Population",
    "section": "The effects of an unrepresentative sample",
    "text": "The effects of an unrepresentative sample\nLet’s step through this with some actual data. Consider trying to answer the question: what was the average GDP earned by countries globally in 2022?\nTo demonstrate the effects of a biased sample, we are going to download all available GDP values for 2022 using the World Bank’s application programming interface (API). We are going to use the wb_data() function from the wbstats R package to do this. I am going to assign the resulting data set to an object called gdp_df.\n\ngdp_df &lt;- wb_data(\"NY.GDP.MKTP.CD\", return_wide = F, start_date = 2022, end_date = 2022) |&gt; \n  # Select only the relevant data points\n  select(iso3c:value)\n\ngdp_df\n\n# A tibble: 217 × 4\n   iso3c country              date         value\n   &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 AFG   Afghanistan          2022  14497243872.\n 2 ALB   Albania              2022  19017242586.\n 3 DZA   Algeria              2022 225638456572.\n 4 ASM   American Samoa       2022    871000000 \n 5 AND   Andorra              2022   3380612573.\n 6 AGO   Angola               2022 104399746853.\n 7 ATG   Antigua and Barbuda  2022   1867733333.\n 8 ARG   Argentina            2022 632790070063.\n 9 ARM   Armenia              2022  19513506553.\n10 ABW   Aruba                2022   3279343544.\n# ℹ 207 more rows\n\n\n\n\n\n\n\n\nTip\n\n\n\nRun ?wb_data in your console to see what arguments the function takes.\n\n\nWe are going to treat this data set as complete. In other words, we will assume that this data set includes the actual GDP values for all countries globally in 2022. This is cheeky for many reasons. Most obviously, we are missing a whole bunch of data points. Let’s identify those:\n\nfilter(gdp_df, is.na(value))\n\n# A tibble: 11 × 4\n   iso3c country                    date value\n   &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt;\n 1 VGB   British Virgin Islands     2022    NA\n 2 CUB   Cuba                       2022    NA\n 3 ERI   Eritrea                    2022    NA\n 4 GIB   Gibraltar                  2022    NA\n 5 GRL   Greenland                  2022    NA\n 6 IMN   Isle of Man                2022    NA\n 7 PRK   Korea, Dem. People's Rep.  2022    NA\n 8 SSD   South Sudan                2022    NA\n 9 MAF   St. Martin (French part)   2022    NA\n10 VEN   Venezuela, RB              2022    NA\n11 YEM   Yemen, Rep.                2022    NA\n\n\n\n\n\n\n\n\nSpoiler alert\n\n\n\nCan you identify anything these missing countries have in common?\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe is.na() function is a logical function (returns either TRUE or FALSE) that asks whether a value is NA, or missing. For example:\n\nis.na(1)\n\n[1] FALSE\n\nis.na(NA)\n\n[1] TRUE\n\n\nWhen supplied to the filter() function, it filters out all the values that are not NA (and are marked as FALSE by the is.na() function).\nTo exclude missing values, you can negate is.na():\n\nfilter(gdp_df, !is.na(value))\n\n# A tibble: 206 × 4\n   iso3c country              date         value\n   &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 AFG   Afghanistan          2022  14497243872.\n 2 ALB   Albania              2022  19017242586.\n 3 DZA   Algeria              2022 225638456572.\n 4 ASM   American Samoa       2022    871000000 \n 5 AND   Andorra              2022   3380612573.\n 6 AGO   Angola               2022 104399746853.\n 7 ATG   Antigua and Barbuda  2022   1867733333.\n 8 ARG   Argentina            2022 632790070063.\n 9 ARM   Armenia              2022  19513506553.\n10 ABW   Aruba                2022   3279343544.\n# ℹ 196 more rows\n\n\nAlternatively, you can use the drop_na() function from the tidyr package:\n\ndrop_na(gdp_df, value)\n\n# A tibble: 206 × 4\n   iso3c country              date         value\n   &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 AFG   Afghanistan          2022  14497243872.\n 2 ALB   Albania              2022  19017242586.\n 3 DZA   Algeria              2022 225638456572.\n 4 ASM   American Samoa       2022    871000000 \n 5 AND   Andorra              2022   3380612573.\n 6 AGO   Angola               2022 104399746853.\n 7 ATG   Antigua and Barbuda  2022   1867733333.\n 8 ARG   Argentina            2022 632790070063.\n 9 ARM   Armenia              2022  19513506553.\n10 ABW   Aruba                2022   3279343544.\n# ℹ 196 more rows\n\n\n\n\nNonetheless, let’s pretend gdp_df includes the actual GDP values for every country in 2022. I am, therefore, going to update the gdp_df object to exclude those missing values:\n\ngdp_df &lt;- drop_na(gdp_df, value)\n\nNow, imagine I - the researcher who wants to work out the average GDP earned by countries globally in 2022 - do not have access to these data. I need to go out and collect them myself. To do this, I intend to send a request for information to every country’s Department of Statistics, asking them for their country’s GDP in 2022. Annoyingly, however, I can only find contact details for some departments. Specifically, I can only find details for departments with very flashy websites that provide a lot of detail on how to contact teams of people whose whole job is to answer such requests for information.\nLet’s update the gdp_df data set to include which countries I found contact details for. We are going to use some simulation here, which I will explain below.\n\n# Find the GDP value the marks the lowest 25 percent of all GDP values in 2022\nfirst_quartile_gdp &lt;- quantile(gdp_df$value, na.rm = T)[[2]]\n\ngdp_df &lt;- gdp_df |&gt; \n  # Create a variable that simulates my finding the contact details for countries with flashy \n  # websites (i.e. rich countries)\n  rowwise() |&gt; \n  mutate(contact_details_found = if_else(value &lt; first_quartile_gdp, \n                                         rbinom(1, 1, 0.10), \n                                         rbinom(1, 1, 0.75))) |&gt; \n  ungroup()\n\n\n\n\n\n\n\nNote\n\n\n\nI am doing a fair bit mechanically here that could distract from my broader point about biased sampling. If, starting to read this note, you find yourself getting a bit lost, please just move on. We will come back to these concepts later.\nJumping ahead to the end, richer countries are more likely than poorer ones to have well-funded, large departments of statistics. To simulate this, I first need a definition of rich countries. I took the 25th percentile as my cut off point. The 25th percentile is the value below which 25 percent of all of the values in a series (ordered from smallest to largest) sit. So, the 25th percentile of my 2022 GDP values is the GDP value below which 25 percent of all other GDP values sit.\nRicher countries are more likely to have departments with accessible teams of people able to field my request for information. This does not mean that they definitely do, nor does it mean no poorer countries do. To account for this, I determine randomly whether a country has contact details based on its GDP value. For poorer countries (those in the lowest 25 percent of all countries), I give them a 10 percent chance I find their contact details. For richer countries (those in the highest 75 percent of all countries), I give them a 75 percent chance I find their contact details. I use the rbinom() function to do this. We will talk about this probability distribution function later in the course.\nI have now simulated data that reflects the constraints I would face as a researcher trying to answer my question.\n\n\nUndeterred, I send out my requests to those departments I have contact details for. I receive some responses:\n\ngdp_responses_df &lt;- gdp_df |&gt; \n  # Only sample from the countries I contacted\n  filter(contact_details_found == 1) |&gt; \n  # Simulate the uneven likelihood I receive responses back (based on wealth)\n  mutate(response_received = if_else(value &lt; first_quartile_gdp,\n                                     rbinom(1, 1, 0.5),\n                                     rbinom(1, 1, 0.8))) |&gt;\n  filter(response_received == 1) |&gt; \n  select(iso3c:value)\n\ngdp_responses_df\n\n# A tibble: 116 × 4\n   iso3c country      date   value\n   &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n 1 AFG   Afghanistan  2022 1.45e10\n 2 ALB   Albania      2022 1.90e10\n 3 DZA   Algeria      2022 2.26e11\n 4 AGO   Angola       2022 1.04e11\n 5 ARM   Armenia      2022 1.95e10\n 6 AUS   Australia    2022 1.69e12\n 7 AUT   Austria      2022 4.72e11\n 8 BHR   Bahrain      2022 4.67e10\n 9 BGD   Bangladesh   2022 4.60e11\n10 BEL   Belgium      2022 5.93e11\n# ℹ 106 more rows\n\n\nNow, if I use this sample to learn something about the average GDP in 2022 for all countries globally, I am going to be wrong.\n\n\n\n\n\n\nQuestion\n\n\n\nCan you guess which way I will be wrong? Will I overstate or understate the global average GDP?\n\n\nHere is the average GDP among my sample:\n\ngdp_responses_df |&gt; \n  summarise(avg_gdp = mean(value)) |&gt; \n  pull() |&gt; \n  dollar()\n\n[1] \"$506,556,083,940\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe scales package includes handy functions for formatting numbers. I have used its dollar() function to format the average GDP nicely.\n\n\nAnd here is the average GDP among the population:\n\ngdp_df |&gt; \n  summarise(avg_gdp = mean(value)) |&gt; \n  pull() |&gt; \n  dollar()\n\n[1] \"$487,688,575,556\"\n\n\nI am overstating the average by a lot! Why? Well, countries that have departments of statistics that are so well funded they can splash out for a fancy website and have a team of people dedicated to fielding requests for information from random academics tend to be wealthy. Poorer countries are less able to spare the funds required to meet my request. I am, therefore, less likely to have found a way to contact them and, even if I did, I am less likely to have received a response from them.\nThis is an example of sampling bias: my sample is systematically different from my population in ways important to my analysis. Wealth is what I am trying to measure, and wealth is influencing who gets into my sample and who does not. Because I do not have a representative sample, I cannot infer from that sample anything about my population.",
    "crumbs": [
      "Content",
      "Session 2",
      "From Samples to the Population"
    ]
  },
  {
    "objectID": "content/02-02-surveys_to_pops.html#largeish-numbers",
    "href": "content/02-02-surveys_to_pops.html#largeish-numbers",
    "title": "From Samples to the Population",
    "section": "Large(ish) numbers",
    "text": "Large(ish) numbers\nIt is not sufficient to have a pure random sample of your population. You also need a sufficiently large sample. To illustrate, consider drawing just one person from your population. Even if you did so entirely randomly, it is unlikely they will reflect the diversity (or even the average view) of the population.\nLet’s return to our attempt to find the average GDP earned by countries globally in 2022 to illustrate this. I am going to select completely randomly five countries from the (cheeky) population using dplyr’s sample_n() function:\n\ngdp_5_df &lt;- sample_n(gdp_df, size = 5)\ngdp_5_df\n\n# A tibble: 5 × 5\n  iso3c country              date   value contact_details_found\n  &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;   &lt;dbl&gt;                 &lt;int&gt;\n1 TTO   Trinidad and Tobago  2022 3.01e10                     1\n2 IDN   Indonesia            2022 1.32e12                     1\n3 XKX   Kosovo               2022 9.35e 9                     1\n4 MDV   Maldives             2022 6.18e 9                     0\n5 MCO   Monaco               2022 8.80e 9                     1\n\n\nThe average GDP among this very small but pure random sample is $274,692,433,009, which is $212,996,142,547 dollars away from the population average.\nWe can do this again to see that it wasn’t just a fluke:\n\ngdp_5_df &lt;- sample_n(gdp_df, size = 5)\ngdp_5_df\n\n# A tibble: 5 × 5\n  iso3c country         date        value contact_details_found\n  &lt;chr&gt; &lt;chr&gt;          &lt;dbl&gt;        &lt;dbl&gt;                 &lt;int&gt;\n1 KIR   Kiribati        2022   270841698.                     0\n2 CUW   Curacao         2022  3075180835.                     0\n3 LCA   St. Lucia       2022  2342703704.                     1\n4 CIV   Cote d'Ivoire   2022 70173140101.                     1\n5 ASM   American Samoa  2022   871000000                      0\n\n\nThe average GDP among this small pure random sample is $15,346,573,268, a $472,342,002,288 dollar difference from the population average.\nIf we increase our sample size, we get closer to the population average:\n\ngdp_175_df &lt;- sample_n(gdp_df, size = 175)\ngdp_175_df\n\n# A tibble: 175 × 5\n   iso3c country                         date   value contact_details_found\n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;   &lt;dbl&gt;                 &lt;int&gt;\n 1 TTO   Trinidad and Tobago             2022 3.01e10                     1\n 2 OMN   Oman                            2022 1.12e11                     0\n 3 KNA   St. Kitts and Nevis             2022 9.81e 8                     0\n 4 PAN   Panama                          2022 7.63e10                     0\n 5 COL   Colombia                        2022 3.45e11                     1\n 6 VCT   St. Vincent and the Grenadines  2022 9.66e 8                     0\n 7 TZA   Tanzania                        2022 7.58e10                     0\n 8 ITA   Italy                           2022 2.10e12                     1\n 9 MHL   Marshall Islands                2022 2.53e 8                     0\n10 GRD   Grenada                         2022 1.22e 9                     0\n# ℹ 165 more rows\n\n\nThe average GDP among this small pure random sample is $546,787,923,128, a mere $59,099,347,572 dollar difference from the population average.\nThe larger your sample size, the closer you will get to the population average. You increase the likelihood you capture the diversity of the population as your sample size increases.",
    "crumbs": [
      "Content",
      "Session 2",
      "From Samples to the Population"
    ]
  },
  {
    "objectID": "content/02-02-surveys_to_pops.html#us-presidential-elections",
    "href": "content/02-02-surveys_to_pops.html#us-presidential-elections",
    "title": "From Samples to the Population",
    "section": "US Presidential Elections",
    "text": "US Presidential Elections\nUS Presidential elections involve thousands of surveys of the US population. Pollsters ask a small subset of that population questions about the election (including which candidate they intend to vote for). They hope to learn from the answers provided by that sample the views of the broader population.\nWe will look at surveys run in the 2020 US Presidential Election. We will learn about overall support for the two candidates (Joe Biden and Donald Trump), and how this support shifted across different demographics. We will then compare that survey to the end result to learn how accurately the survey reflected the population’s views.\nA survey of votes cast\nWe are going to look at the American National Election Studies pre-election survey. The ANES conducts surveys on voting, public opinion, and political participation. You can learn more about them from their website.\nTo download the data, you will need to head over to the ANES website, download the relevant file, and save it in your RProject. The following video demonstrates how to do this.\nOnce you have collected the data, you can read it in using the readr package’s read_csv() function. It takes the file’s path as its first argument.\n\nanes_raw &lt;- read_csv(here(\"content\", \"data\", \"anes_timeseries_2020_csv_20220210.csv\"))\nanes_raw\n\n# A tibble: 8,280 × 1,771\n   version  V200001 V160001_orig V200002 V200003 V200004 V200005 V200006 V200007\n   &lt;chr&gt;      &lt;dbl&gt;        &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 ANES202…  200015       401318       3       2       3       0      -2      -2\n 2 ANES202…  200022       300261       3       2       3       0       4      -1\n 3 ANES202…  200039       400181       3       2       3       0      -2      -2\n 4 ANES202…  200046       300171       3       2       3       0      -2      -2\n 5 ANES202…  200053       405145       3       2       3       1      -2      -2\n 6 ANES202…  200060       400374       3       2       3       0      -2      -2\n 7 ANES202…  200084       407013       3       2       3       0      -2      -2\n 8 ANES202…  200091       407174       3       2       3       0      -2      -2\n 9 ANES202…  200107       406264       3       2       3       0      -2      -2\n10 ANES202…  200114       402782       3       2       3       1       4      -1\n# ℹ 8,270 more rows\n# ℹ 1,762 more variables: V200008 &lt;dbl&gt;, V200009 &lt;dbl&gt;, V200010a &lt;dbl&gt;,\n#   V200010b &lt;dbl&gt;, V200010c &lt;dbl&gt;, V200010d &lt;dbl&gt;, V200011a &lt;dbl&gt;,\n#   V200011b &lt;dbl&gt;, V200011c &lt;dbl&gt;, V200011d &lt;dbl&gt;, V200012a &lt;dbl&gt;,\n#   V200012b &lt;dbl&gt;, V200012c &lt;dbl&gt;, V200012d &lt;dbl&gt;, V200013a &lt;dbl&gt;,\n#   V200013b &lt;dbl&gt;, V200013c &lt;dbl&gt;, V200013d &lt;dbl&gt;, V200014a &lt;dbl&gt;,\n#   V200014b &lt;dbl&gt;, V200014c &lt;dbl&gt;, V200014d &lt;dbl&gt;, V200015a &lt;dbl&gt;, …\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe here R package makes saving data in a robust way very easy. Using here::here(), you can automatically update file paths to reflect the computer you are currently using. To demonstrate, run the following code:\n\nhere::here()\n\n[1] \"/Users/harrietgoers/Documents/GVPT399F\"\n\n\nYour output will be different to mine. here::here() locates the top level of the file directory in which you are located. This is helpful when you share your code with others (or switch to a new computer). Hard coded file paths will cause annoying errors.\nI like to save my data in a folder called data. You can use a structure you find works for you.\n\n\nEach row of this data set represents a single respondent. Therefore, we can quickly note that in 2020, the ANES surveyed 8,280 people.\nThe ANES asks a lot of questions of its respondents. Full details of these questions can be found in their survey questionnaire document. We are interested in learning whether the survey respondents reflect the behavior of all US voters in the 2020 US Presidential election. To answer this question, we are going to focus on their response to the question: which Presidential candidate did you vote for?\nThis question was only asked of respondents who had already told the interviewer that they voted for a US president. Not all respondents voted, so we need to remove those who did not from our data set.\nWe will then match these data to the total vote count each candidate won in the election to see if they are similar.\nLet’s start by transforming our data set into one that is more suitable for this analysis:\n\nanes_df &lt;- anes_raw |&gt; \n  select(respondent_id = V200001,\n         voted_for_pres = V202072,\n         pres_vote = V202073)\n\nanes_df\n\n# A tibble: 8,280 × 3\n   respondent_id voted_for_pres pres_vote\n           &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;\n 1        200015             -1        -1\n 2        200022              1         3\n 3        200039              1         1\n 4        200046              1         1\n 5        200053              1         2\n 6        200060              1         1\n 7        200084              1         2\n 8        200091             -1        -1\n 9        200107             -1        -1\n10        200114              1         1\n# ℹ 8,270 more rows\n\n\nIndividuals’ responses are coded as numbers, which are easily interpreted by the computer, but not by us humans. Let’s recode the responses so we know what they are. They are categorical variables (which R refers to as factors). Currently, they are coded as numbers (&lt;dbl&gt;). To convert them to factors, we need to use factor() within mutate():\n\nanes_df &lt;- anes_df |&gt; \n  mutate(voted_for_pres = factor(voted_for_pres, levels = 1:2, \n                                 labels = c(\"Yes, voted for President\",\n                                            \"No, didn’t vote for President\")),\n         pres_vote = factor(pres_vote, levels = 1:5,\n                            labels = c(\"DEMOCRAT\",\n                                       \"REPUBLICAN\",\n                                       \"LIBERTARIAN\",\n                                       \"GREENS\",\n                                       \"OTHER\")))\n\nanes_df\n\n# A tibble: 8,280 × 3\n   respondent_id voted_for_pres           pres_vote  \n           &lt;dbl&gt; &lt;fct&gt;                    &lt;fct&gt;      \n 1        200015 &lt;NA&gt;                     &lt;NA&gt;       \n 2        200022 Yes, voted for President LIBERTARIAN\n 3        200039 Yes, voted for President DEMOCRAT   \n 4        200046 Yes, voted for President DEMOCRAT   \n 5        200053 Yes, voted for President REPUBLICAN \n 6        200060 Yes, voted for President DEMOCRAT   \n 7        200084 Yes, voted for President REPUBLICAN \n 8        200091 &lt;NA&gt;                     &lt;NA&gt;       \n 9        200107 &lt;NA&gt;                     &lt;NA&gt;       \n10        200114 Yes, voted for President DEMOCRAT   \n# ℹ 8,270 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\nI got the response labels from the survey questionnaire linked above.\n\n\n\n\n\n\n\n\nTip\n\n\n\nfactor() takes as its first argument the name of the column you would like to convert to a factor. You then specify which numbers you need to code as your values using the levels argument. Finally, you supply the more human-friendly name of those values in the labels argument.\n\n\nI now have a much cleaner version of my data set. Next, we need to exclude those respondents who did not vote for any Presidential candidate or who did not respond to the interviewer’s question about which candidate they voted for:\n\npres_voted_df &lt;- anes_df |&gt; \n  filter(voted_for_pres == \"Yes, voted for President\") |&gt; \n  drop_na(pres_vote)\n\npres_voted_df\n\n# A tibble: 5,877 × 3\n   respondent_id voted_for_pres           pres_vote  \n           &lt;dbl&gt; &lt;fct&gt;                    &lt;fct&gt;      \n 1        200022 Yes, voted for President LIBERTARIAN\n 2        200039 Yes, voted for President DEMOCRAT   \n 3        200046 Yes, voted for President DEMOCRAT   \n 4        200053 Yes, voted for President REPUBLICAN \n 5        200060 Yes, voted for President DEMOCRAT   \n 6        200084 Yes, voted for President REPUBLICAN \n 7        200114 Yes, voted for President DEMOCRAT   \n 8        200121 Yes, voted for President DEMOCRAT   \n 9        200138 Yes, voted for President DEMOCRAT   \n10        200152 Yes, voted for President REPUBLICAN \n# ℹ 5,867 more rows\n\n\nWe now have data on 5,877 individuals who voted for a Presidential candidate and provided their vote to the interviewer. Let’s take a look at the total number of votes each candidate received:\n\npres_voted_df |&gt; \n  count(pres_vote) |&gt; \n  ggplot(aes(x = n, y = reorder(pres_vote, n))) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"Votes received\",\n       y = NULL)\n\n\n\n\n\n\n\nJoe Biden (the Democratic candidate) received the most votes among the ANES survey respondents. Let’s represent this as vote proportions so we can more easily compare it to the votes received by each candidate nationally:\n\npres_voted_df |&gt; \n  count(pres_vote) |&gt; \n  mutate(prop = n / sum(n)) |&gt; \n  ggplot(aes(x = prop, y = reorder(pres_vote, prop))) + \n  geom_col() + \n  theme_minimal() + \n  labs(x = \"Precentage of total votes\",\n       y = NULL) + \n  scale_x_continuous(labels = percent)\n\n\n\n\n\n\n\nThe population of votes cast\nSo, were they right? To answer this question, we need to get data on the total number of votes each Presidential candidate received in 2020. The MIT Election Data + Science Lab provides these returns to the public. To access their data, we will use the Harvard Dataverse API. We will access it using the R package dataverse.\n\n\n\n\n\n\nNote\n\n\n\nThe dataverse package accesses the Harvard Dataverse Application Programming Interface (API) in the background. To learn more about how to access this API directly, check out the Harvard Dataverse documentation.\n\n\nWe will be accessing the U.S. President 1976–2020 data set. To do this, we need three pieces of information:\n\nThe name of the file we want to download\nThe data set’s DOI\nThe data set’s format\n\nWe can get all of this information from the data set’s page on the Harvard Dataverse website.\n\npres_results_df &lt;- get_dataframe_by_name(\n  filename = \"1976-2020-president.tab\",\n  dataset = \"10.7910/DVN/42MVDX\",\n  server = \"dataverse.harvard.edu\",\n  original = T,\n  .f = readr::read_csv\n)\n\nThis code programmatically pulls the most up-to-date data set from the API. Once the MIT Election Lab publishes the 2024 Presidential Election data, you will only need to update the file name to be able to access it.\nWe are interested in looking at the 2020 Presidential Election, so we will transform our data to exclude all others. Also, these data are at the state-level. We need to aggregate them up to the national level.\nWe do both of these things in the following code chunk:\n\npres_results_2020_df &lt;- pres_results_df |&gt; \n  filter(year == 2020) |&gt; \n  group_by(party_simplified) |&gt; \n  summarise(candidatevotes = sum(candidatevotes)) |&gt; \n  ungroup()\n\npres_results_2020_df\n\n# A tibble: 4 × 2\n  party_simplified candidatevotes\n  &lt;chr&gt;                     &lt;dbl&gt;\n1 DEMOCRAT               81268908\n2 LIBERTARIAN             1797355\n3 OTHER                   1246094\n4 REPUBLICAN             74216146\n\n\nFinally, we will calculate the proportion of votes each candidate received to make it comparable to the survey results:\n\npres_results_national_df &lt;- pres_results_2020_df |&gt; \n  mutate(prop_pop = candidatevotes / sum(candidatevotes))\n\nggplot(pres_results_national_df, aes(x = prop_pop, y = reorder(party_simplified, prop_pop))) + \n  geom_col() +\n  theme_minimal() + \n  labs(x = \"Percentage of total votes\",\n       y = NULL) + \n  scale_x_continuous(labels = percent)\n\n\n\n\n\n\n\nThe MIT Election Lab folds the Greens party into the “other” category, whereas the ANES separates them out. To make these comparable, we need to fold the Greens votes into the “other” category. We can do this using the forcats package’s (loaded in with the tidyverse) fct_recode() function:\n\nanes_df &lt;- mutate(anes_df, pres_vote = fct_recode(pres_vote, OTHER = \"GREENS\"))\n\nanes_national_results &lt;- anes_df |&gt; \n  filter(voted_for_pres == \"Yes, voted for President\" & !is.na(pres_vote)) |&gt; \n  count(pres_vote) |&gt; \n  transmute(party_simplified = pres_vote, prop_survey = n / sum(n))\n\nNow we can compare these two:\n\npres_results_national_df |&gt; \n  left_join(anes_national_results, by = join_by(party_simplified)) |&gt; \n  pivot_longer(prop_pop:prop_survey) |&gt; \n  mutate(name = case_when(name == \"prop_pop\" ~ \"Population\",\n                          name == \"prop_survey\" ~ \"Survey\")) |&gt; \n  ggplot(aes(x = value, y = reorder(party_simplified, value), fill = name)) + \n  geom_col(position = \"dodge\") + \n  theme_minimal() + \n  labs(x = \"Percentage of total votes\",\n       y = NULL, \n       fill = NULL) + \n  scale_x_continuous(labels = percent)\n\n\n\n\n\n\n\nIt looks like the ANES did a fairly good job of capturing the US voting population’s behavior. The proportion of survey respondents who said they voted for each candidate (represented by the blue bar) is roughly equal to the proportion of votes won by each candidate (represented by the pink bar).\nOne interesting thing to note is that the survey did overstate support for Joe Biden and understated support for Donald Trump. We might see this despite having a representative sample. For example, people - when asked who they voted for - may be inclined to say they voted for the winner (regardless of who that winner was). Also, individuals may be hesitant to tell a pollster that they voted for Donald Trump given how divisive he and his campaign were.\nIt is; however, very likely that the ANES did not reach a representative sample of the US voting population. As we discussed above: this is very difficult (if not impossible) to do. ANES runs very good surveys precisely because they acknowledge and, to the best of their ability, account for this. Generally, surveys will compare the demographics of their respondents to those of the voting population (or population more generally). If they find that some individuals are under-represented in their sample (for example, young black women make up a smaller proportion of their sample than they make up in the population), they will make the responses of individuals who fit those demographics count for more than one response in their calculations. Similarly, if they find a demographic is over-represented in their sample, they will make their responses count for less than one response in their calculations. This practice is called weighting and it is standard across all major and respected surveys.",
    "crumbs": [
      "Content",
      "Session 2",
      "From Samples to the Population"
    ]
  },
  {
    "objectID": "content/slides/02-09-surveys.html#surveys",
    "href": "content/slides/02-09-surveys.html#surveys",
    "title": "From Surveys to Populations",
    "section": "Surveys",
    "text": "Surveys\n\nPopulations are very difficult to collect data on\n\nEven the census misses people!\n\nHappily, we can use surveys of a sample of our population to learn things about our population\nHowever, our ability to do this is conditional on how good our sample is\nWhat do I mean by “good”?"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#the-2024-us-presidential-election",
    "href": "content/slides/02-09-surveys.html#the-2024-us-presidential-election",
    "title": "From Surveys to Populations",
    "section": "The 2024 US Presidential Election",
    "text": "The 2024 US Presidential Election\n\nElections are preceded by a flood of surveys"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#surveys-1",
    "href": "content/slides/02-09-surveys.html#surveys-1",
    "title": "From Surveys to Populations",
    "section": "Surveys",
    "text": "Surveys\n\nSurveys are conducted on a subset (sample) of the population of interest\nOur population of interest: individuals who voted in the 2024 US Presidential Election"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#a-good-sample",
    "href": "content/slides/02-09-surveys.html#a-good-sample",
    "title": "From Surveys to Populations",
    "section": "A good sample",
    "text": "A good sample\n\nA good sample is a representative one\nHow closely does our sample reflect our population"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#parallel-worlds",
    "href": "content/slides/02-09-surveys.html#parallel-worlds",
    "title": "From Surveys to Populations",
    "section": "Parallel worlds",
    "text": "Parallel worlds\n\nRemember back to last session on experiments\nIn an ideal world, we would be able to create two parallel worlds (one with the treatment, one held as our control)\n\nOne version of the election booth run without monitors (the control)\nOne version with monitors (the treatment)\n\nThese worlds are perfectly identical to each other prior to treatment\nWe cannot do this :("
  },
  {
    "objectID": "content/slides/02-09-surveys.html#the-next-best-thing",
    "href": "content/slides/02-09-surveys.html#the-next-best-thing",
    "title": "From Surveys to Populations",
    "section": "The next best thing",
    "text": "The next best thing\n\nOur next best option is to create two groups that were as identical to one another as possible prior to treatment\nIf they are (almost) identical, differences between their group-wide outcomes can be attributed to the treatment\nOne good way of getting two (almost) identical groups is to assign individuals to those groups randomly\n\nThink back to our 1,000 hypothetical people!"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#randomization",
    "href": "content/slides/02-09-surveys.html#randomization",
    "title": "From Surveys to Populations",
    "section": "Randomization",
    "text": "Randomization\n\nRandomization continues to pop its chaotic head up\nWe can use it to create a sample that is (almost) identical to our population, on average\nDrawing randomly from our population increases our chances of ending up with a sample that reflects that population\nThis would be referred to as a representative sample"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#random-sampling",
    "href": "content/slides/02-09-surveys.html#random-sampling",
    "title": "From Surveys to Populations",
    "section": "Random sampling",
    "text": "Random sampling\n\nAll individuals in the population need to have an equal chance of being selected for the sample\n\nIf this holds, you have a pure random sample\n\nThis is really hard to do!\n\nHow likely were you to answer the pollster’s unknown number, calling you in the middle of the day?\nEven if you did answer, how likely were you to answer all their questions?"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#to-illustrate",
    "href": "content/slides/02-09-surveys.html#to-illustrate",
    "title": "From Surveys to Populations",
    "section": "To illustrate",
    "text": "To illustrate\nCountries’ GDP in 2022:"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#countries-gdp",
    "href": "content/slides/02-09-surveys.html#countries-gdp",
    "title": "From Surveys to Populations",
    "section": "Countries’ GDP",
    "text": "Countries’ GDP\nI want to estimate the average GDP across all countries in 2022.\n\nI send out a survey to all countries’ Departments of Statistics and ask for their GDP figures for 2022.\nI get 60 responses:\n\n\nsample_df &lt;- gdp_df |&gt; \n  drop_na(sample_value) |&gt; \n  sample_n(size = 60) |&gt; \n  transmute(country, gdp = sample_value)\n\nsample_df\n\n# A tibble: 60 × 2\n   country                    gdp\n   &lt;chr&gt;                    &lt;dbl&gt;\n 1 Sweden           590409594949.\n 2 Moldova           14510490660.\n 3 Turkmenistan      56542857143.\n 4 Guinea            20999229260.\n 5 Nepal             41182939601.\n 6 Colombia         345329875079.\n 7 Jordan            48653381831.\n 8 Curacao            3073840325.\n 9 Belize             2830507576.\n10 Congo, Dem. Rep.  65801547620.\n# ℹ 50 more rows"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#countries-gdp-1",
    "href": "content/slides/02-09-surveys.html#countries-gdp-1",
    "title": "From Surveys to Populations",
    "section": "Countries’ GDP",
    "text": "Countries’ GDP\nI now calculate the average of these responses, which I find to be:\n\nsample_df |&gt; \n  summarise(avg_gdp = scales::dollar(mean(gdp, na.rm = T)))\n\n# A tibble: 1 × 1\n  avg_gdp         \n  &lt;chr&gt;           \n1 $204,457,683,828\n\n\nNow, imagine that we knew definitively that it was NA. Why such a large difference?"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#non-response-bias",
    "href": "content/slides/02-09-surveys.html#non-response-bias",
    "title": "From Surveys to Populations",
    "section": "Non-response bias",
    "text": "Non-response bias\nPoorer countries are far less likely to be able or willing to provide these economic data to academics or international organizations.\n\nThey tend to be underrepresented in a lot of data\n\nMy sample was biased against poorer countries.\n\nThey were not equally likely to respond to my request for data as rich countries"
  },
  {
    "objectID": "content/slides/02-09-surveys.html#large-numbers",
    "href": "content/slides/02-09-surveys.html#large-numbers",
    "title": "From Surveys to Populations",
    "section": "Large numbers",
    "text": "Large numbers\n\nRandomization isn’t enough: we also need to draw a sufficiently large sample from our population\n\nOne person pulled randomly from the class isn’t going to be very reflective of the class!"
  },
  {
    "objectID": "content/03-01-wrangling.html#lengthening-messy-data",
    "href": "content/03-01-wrangling.html#lengthening-messy-data",
    "title": "Data Wrangling",
    "section": "Lengthening messy data",
    "text": "Lengthening messy data\nThe World Bank provides us with access to a trove of official country- and sub-national level data that are very useful for political analysis. I use their data in nearly all of my research. Sadly, they tend to provide their data in a messy format. We will now collect that messy data so we can learn how to tidy it up.\nTo access their data and some wonderful data visualizations, you can head over to their data portal: https://data.worldbank.org/. From there, you can browse which data sets they have or search for ones you are interested in.\nWe are going to start by collecting data on countries’ GDP per capita (current US$). It can be accessed here: https://data.worldbank.org/indicator/NY.GDP.PCAP.CD. You can download the data directly from this web page, save it in the appropriate place in your RProject, and read it in from there.\n\n\n\n\n\n\nNote\n\n\n\nThis process is similar to the one we used in Session 2: From Samples to the Population.\n\n\nI saved the CSV in the data folder (which is the in the content folder because this is a website), so I will use here::here() to adaptively find the correct file path and read the file in using read_csv().\n\ngdp_per_cap_raw &lt;- read_csv(here::here(\"content\", \"data\", \n                                       \"API_NY.GDP.PCAP.CD_DS2_en_csv_v2_76.csv\"))\n\nAfter running this yourself, you will see an ominous warning. Let’s take a look at our data:\n\ngdp_per_cap_raw\n\n# A tibble: 268 × 3\n   `Data Source`               `World Development Indicators` ...3              \n   &lt;chr&gt;                       &lt;chr&gt;                          &lt;chr&gt;             \n 1 Last Updated Date           2024-12-16                      &lt;NA&gt;             \n 2 Country Name                Country Code                   \"Indicator Name,I…\n 3 Aruba                       ABW                            \"GDP per capita (…\n 4 Africa Eastern and Southern AFE                            \"GDP per capita (…\n 5 Afghanistan                 AFG                            \"GDP per capita (…\n 6 Africa Western and Central  AFW                            \"GDP per capita (…\n 7 Angola                      AGO                            \"GDP per capita (…\n 8 Albania                     ALB                            \"GDP per capita (…\n 9 Andorra                     AND                            \"GDP per capita (…\n10 Arab World                  ARB                            \"GDP per capita (…\n# ℹ 258 more rows\n\n\nWe have only three columns, none of which appear to have the right names. It also looks like the first few rows may, in fact, not be rows in our data set. Rather, they are metadata, including the last time the data were updated.\nThe second row in our data set looks like the real column headings. This is good! We can skip the first few rows using read_csv()’s skip argument. Just provide it with the number of rows you want to skip when reading in the CSV.\n\ngdp_per_cap_raw &lt;- read_csv(here::here(\"content\", \"data\", \n                                       \"API_NY.GDP.PCAP.CD_DS2_en_csv_v2_76.csv\"),\n                            skip = 3)\n\ngdp_per_cap_raw\n\n# A tibble: 266 × 69\n   `Country Name` `Country Code` `Indicator Name` `Indicator Code` `1960` `1961`\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;            &lt;chr&gt;             &lt;dbl&gt;  &lt;dbl&gt;\n 1 Aruba          ABW            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 2 Africa Easter… AFE            GDP per capita … NY.GDP.PCAP.CD     186.   187.\n 3 Afghanistan    AFG            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 4 Africa Wester… AFW            GDP per capita … NY.GDP.PCAP.CD     122.   127.\n 5 Angola         AGO            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 6 Albania        ALB            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 7 Andorra        AND            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n 8 Arab World     ARB            GDP per capita … NY.GDP.PCAP.CD      NA    213.\n 9 United Arab E… ARE            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n10 Argentina      ARG            GDP per capita … NY.GDP.PCAP.CD      NA     NA \n# ℹ 256 more rows\n# ℹ 63 more variables: `1962` &lt;dbl&gt;, `1963` &lt;dbl&gt;, `1964` &lt;dbl&gt;, `1965` &lt;dbl&gt;,\n#   `1966` &lt;dbl&gt;, `1967` &lt;dbl&gt;, `1968` &lt;dbl&gt;, `1969` &lt;dbl&gt;, `1970` &lt;dbl&gt;,\n#   `1971` &lt;dbl&gt;, `1972` &lt;dbl&gt;, `1973` &lt;dbl&gt;, `1974` &lt;dbl&gt;, `1975` &lt;dbl&gt;,\n#   `1976` &lt;dbl&gt;, `1977` &lt;dbl&gt;, `1978` &lt;dbl&gt;, `1979` &lt;dbl&gt;, `1980` &lt;dbl&gt;,\n#   `1981` &lt;dbl&gt;, `1982` &lt;dbl&gt;, `1983` &lt;dbl&gt;, `1984` &lt;dbl&gt;, `1985` &lt;dbl&gt;,\n#   `1986` &lt;dbl&gt;, `1987` &lt;dbl&gt;, `1988` &lt;dbl&gt;, `1989` &lt;dbl&gt;, `1990` &lt;dbl&gt;, …\n\n\nThat looks better! We have now read in the data set itself, skipping those rows of metadata.\nThe resulting data set is a wide one. Each observation is a country or region. The first two columns provide information on the country. The third and fourth describe the indicator. All other columns provide each country’s GDP per capita in all years from 1960 to 2023.\nNow, imagine you want to compare a country’s GDP per capita across many years. For example, you want to know how Australians’ wealth has grown over time. This is very difficult to do with this current format. We would need to work with all columns from 1960 to 2023!\nTo make these data easier to work with, we will lengthen the data set. Instead of each observation (row) describing a country, we will make each observation describe a country-year.\nTo do this, we need to use pivot_longer(). We need to let it know which columns we want to transpose using the col argument. Because the end year for these data will change each year I want to pull and clean up this data set (for example, next year the last column will be 2024, not 2023), I will use ! to negate the columns I don’t want to transpose. This code will, therefore, work after each annual update to the data set.\n\ngdp_per_cap &lt;- gdp_per_cap_raw |&gt; \n  pivot_longer(cols = !c(`Country Name`:`Indicator Code`),\n               names_to = \"year\",\n               values_to = \"gdp_per_cap\")\n\ngdp_per_cap\n\n# A tibble: 17,290 × 6\n   `Country Name` `Country Code` `Indicator Name`         `Indicator Code` year \n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;chr&gt;            &lt;chr&gt;\n 1 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1960 \n 2 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1961 \n 3 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1962 \n 4 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1963 \n 5 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1964 \n 6 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1965 \n 7 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1966 \n 8 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1967 \n 9 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1968 \n10 Aruba          ABW            GDP per capita (current… NY.GDP.PCAP.CD   1969 \n# ℹ 17,280 more rows\n# ℹ 1 more variable: gdp_per_cap &lt;dbl&gt;\n\n\nI have also told pivot_longer() what to call the column containing the previous column names (using names_to) and the column containing the values (using values_to).\nYou might have noticed that I needed to include some back ticks when referencing those column names. This is because these column names do not follow the rules put in place to help you work with R. Column names must:\n\nNot include spaces\nNot start with numbers or special characters\n\nThey should also be:\n\nShort\nMeaningful\nConsistently formatted\n\nThe World Bank uses spaces in its column names. We need to remove those so we can more easily work with them in R. Happily, the very handy janitor R package is here for all of your cleaning needs!\nI use the clean_names() function to ensure names are clean and consistent:\n\ngdp_per_cap &lt;- clean_names(gdp_per_cap)\ngdp_per_cap\n\n# A tibble: 17,290 × 6\n   country_name country_code indicator_name     indicator_code year  gdp_per_cap\n   &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;              &lt;chr&gt;          &lt;chr&gt;       &lt;dbl&gt;\n 1 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1960           NA\n 2 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1961           NA\n 3 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1962           NA\n 4 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1963           NA\n 5 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1964           NA\n 6 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1965           NA\n 7 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1966           NA\n 8 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1967           NA\n 9 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1968           NA\n10 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD 1969           NA\n# ℹ 17,280 more rows\n\n\nGreat! We’re almost there. Next, we need to check that R has correctly classified our data types. For example, we want to make sure that the years are coded as numbers not strings of characters.\n\nglimpse(gdp_per_cap)\n\nRows: 17,290\nColumns: 6\n$ country_name   &lt;chr&gt; \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"…\n$ country_code   &lt;chr&gt; \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\", \"ABW\",…\n$ indicator_name &lt;chr&gt; \"GDP per capita (current US$)\", \"GDP per capita (curren…\n$ indicator_code &lt;chr&gt; \"NY.GDP.PCAP.CD\", \"NY.GDP.PCAP.CD\", \"NY.GDP.PCAP.CD\", \"…\n$ year           &lt;chr&gt; \"1960\", \"1961\", \"1962\", \"1963\", \"1964\", \"1965\", \"1966\",…\n$ gdp_per_cap    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\n\nHmm, it does appear to have read the years in as characters. Why?\n\nunique(gdp_per_cap$year)\n\n [1] \"1960\"  \"1961\"  \"1962\"  \"1963\"  \"1964\"  \"1965\"  \"1966\"  \"1967\"  \"1968\" \n[10] \"1969\"  \"1970\"  \"1971\"  \"1972\"  \"1973\"  \"1974\"  \"1975\"  \"1976\"  \"1977\" \n[19] \"1978\"  \"1979\"  \"1980\"  \"1981\"  \"1982\"  \"1983\"  \"1984\"  \"1985\"  \"1986\" \n[28] \"1987\"  \"1988\"  \"1989\"  \"1990\"  \"1991\"  \"1992\"  \"1993\"  \"1994\"  \"1995\" \n[37] \"1996\"  \"1997\"  \"1998\"  \"1999\"  \"2000\"  \"2001\"  \"2002\"  \"2003\"  \"2004\" \n[46] \"2005\"  \"2006\"  \"2007\"  \"2008\"  \"2009\"  \"2010\"  \"2011\"  \"2012\"  \"2013\" \n[55] \"2014\"  \"2015\"  \"2016\"  \"2017\"  \"2018\"  \"2019\"  \"2020\"  \"2021\"  \"2022\" \n[64] \"2023\"  \"...69\"\n\n\nLooking at all unique values included in the year column, we can see the culprit: \"...69\". It looks like the CSV includes a rouge last column with no data in it. read_csv() read that column in and coded all its values as NA:\n\ngdp_per_cap |&gt; \n  filter(year == \"...69\") |&gt; \n  distinct(gdp_per_cap)\n\n# A tibble: 1 × 1\n  gdp_per_cap\n        &lt;dbl&gt;\n1          NA\n\n\nWe can simply filter this out of our data set to get rid of it and convert the remaining values to numbers using mutate():\n\ngdp_per_cap &lt;- gdp_per_cap |&gt; \n  filter(year != \"...69\") |&gt; \n  mutate(year = as.numeric(year))\ngdp_per_cap\n\n# A tibble: 17,024 × 6\n   country_name country_code indicator_name     indicator_code  year gdp_per_cap\n   &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;              &lt;chr&gt;          &lt;dbl&gt;       &lt;dbl&gt;\n 1 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1960          NA\n 2 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1961          NA\n 3 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1962          NA\n 4 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1963          NA\n 5 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1964          NA\n 6 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1965          NA\n 7 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1966          NA\n 8 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1967          NA\n 9 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1968          NA\n10 Aruba        ABW          GDP per capita (c… NY.GDP.PCAP.CD  1969          NA\n# ℹ 17,014 more rows\n\n\nWe now have a nice and clean data set that is easy to work with. Let’s take a look at Australia’s growth over time:\n\ngdp_per_cap |&gt; \n  filter(country_name == \"Australia\") |&gt; \n  ggplot(aes(x = year, y = gdp_per_cap)) + \n  geom_line() + \n  geom_point(size = 1) + \n  theme_minimal() + \n  labs(x = \"Year\",\n       y = \"GDP per capita (current US$)\") + \n  scale_y_continuous(labels = dollar)",
    "crumbs": [
      "Content",
      "Session 3",
      "Data Wrangling"
    ]
  },
  {
    "objectID": "content/03-01-wrangling.html#widening-messy-data",
    "href": "content/03-01-wrangling.html#widening-messy-data",
    "title": "Data Wrangling",
    "section": "Widening messy data",
    "text": "Widening messy data\nSometimes you want to widen your data. tidyr provides a similar function, pivot_wider(), to do just this. Let’s start by getting some long data. We will again collect these data from the World Bank, but this time we will use wbstats to access it directly through the API.\nWe will add to our data set information on each country’s average life expectancy (ID: SP.DYN.LE00.IN).\n\ngapminder_raw &lt;- wb_data(\n  indicator = c(\"SP.DYN.LE00.IN\", \"NY.GDP.PCAP.CD\"),\n  return_wide = F\n)\n\ngapminder_raw\n\n# A tibble: 27,776 × 11\n   indicator_id   indicator     iso2c iso3c country  date value unit  obs_status\n   &lt;chr&gt;          &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n 1 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2023  NA   &lt;NA&gt;  &lt;NA&gt;      \n 2 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2022  62.9 &lt;NA&gt;  &lt;NA&gt;      \n 3 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2021  62.0 &lt;NA&gt;  &lt;NA&gt;      \n 4 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2020  62.6 &lt;NA&gt;  &lt;NA&gt;      \n 5 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2019  63.6 &lt;NA&gt;  &lt;NA&gt;      \n 6 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2018  63.1 &lt;NA&gt;  &lt;NA&gt;      \n 7 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2017  63.0 &lt;NA&gt;  &lt;NA&gt;      \n 8 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2016  63.1 &lt;NA&gt;  &lt;NA&gt;      \n 9 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2015  62.7 &lt;NA&gt;  &lt;NA&gt;      \n10 SP.DYN.LE00.IN Life expecta… AF    AFG   Afghan…  2014  62.5 &lt;NA&gt;  &lt;NA&gt;      \n# ℹ 27,766 more rows\n# ℹ 2 more variables: footnote &lt;chr&gt;, last_updated &lt;date&gt;\n\n\n\n\n\n\n\n\nNote\n\n\n\nBy default, the wonderful wb_data() function will return data to you in a clean (and wide) format. Therefore, to illustrate how to wrangle these data, I need to include the return_wide = F argument.\n\n\nWe now have data on each country-year-indicator. For example, let’s look at what we have for Afghanistan in 2018:\n\ngapminder_raw |&gt; \n  filter(country == \"Afghanistan\", date == 2018)\n\n# A tibble: 2 × 11\n  indicator_id   indicator      iso2c iso3c country  date value unit  obs_status\n  &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n1 SP.DYN.LE00.IN Life expectan… AF    AFG   Afghan…  2018  63.1 &lt;NA&gt;  &lt;NA&gt;      \n2 NY.GDP.PCAP.CD GDP per capit… AF    AFG   Afghan…  2018 491.  &lt;NA&gt;  &lt;NA&gt;      \n# ℹ 2 more variables: footnote &lt;chr&gt;, last_updated &lt;date&gt;\n\n\nThis is difficult to work with. For example, think about how you would plot each country’s GDP per capita against its average life expectancy for a single year.\nWe need to make these data wider. We want our observations to be country-year. We will therefore have a column for each country-year’s GDP per capita and its average life expectancy.\npivot_wider() works by creating a new column for each unique value in the column you tell it to draws names from (using the names_from argument). It will then populate that column with the corresponding value from the column you tell it to draw values from (using the values_from argument). It preserves all unique values in the other rows.\nThis is a little easier to understand in practice. Let’s step through widening our Gapminder data. I’ll start by diving straight in:\n\npivot_wider(gapminder_raw, names_from = indicator_id, values_from = value)\n\n# A tibble: 27,776 × 11\n   indicator    iso2c iso3c country  date unit  obs_status footnote last_updated\n   &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;    &lt;date&gt;      \n 1 Life expect… AF    AFG   Afghan…  2023 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 2 Life expect… AF    AFG   Afghan…  2022 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 3 Life expect… AF    AFG   Afghan…  2021 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 4 Life expect… AF    AFG   Afghan…  2020 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 5 Life expect… AF    AFG   Afghan…  2019 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 6 Life expect… AF    AFG   Afghan…  2018 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 7 Life expect… AF    AFG   Afghan…  2017 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 8 Life expect… AF    AFG   Afghan…  2016 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 9 Life expect… AF    AFG   Afghan…  2015 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n10 Life expect… AF    AFG   Afghan…  2014 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n# ℹ 27,766 more rows\n# ℹ 2 more variables: SP.DYN.LE00.IN &lt;dbl&gt;, NY.GDP.PCAP.CD &lt;dbl&gt;\n\n\nWe now have two new columns: SP.DYN.LE00.IN for average life expectancy, and NY.GDP.PCAP.CD for GDP per capita. These columns contain the corresponding values for each country-year’s average life expectancy and GDP per capita.\nHowever, something has gone wrong. Our wider data set should have fewer rows than our longer one. This is because we are hoping to have one row for each country-year containing information on its average life expectancy and GDP per capita for each year, rather than two rows for each country-year (one for each indicator). Why is this happening?\nWell, the World Bank data set includes unique information about each indicator in the indicator column. Because this is country-year-indicator level information, pivot_wider() - in an attempt to preserve that information - creates a country-year-indicator level data set. To tidy and widen our data set, we need to remove all country-year-indicator level information and then pivot it.\n\ngapminder &lt;- gapminder_raw |&gt;\n  select(!indicator) |&gt; \n  pivot_wider(names_from = indicator_id, values_from = value)\ngapminder\n\n# A tibble: 13,897 × 10\n   iso2c iso3c country      date unit  obs_status footnote last_updated\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;    &lt;date&gt;      \n 1 AF    AFG   Afghanistan  2023 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 2 AF    AFG   Afghanistan  2022 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 3 AF    AFG   Afghanistan  2021 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 4 AF    AFG   Afghanistan  2020 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 5 AF    AFG   Afghanistan  2019 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 6 AF    AFG   Afghanistan  2018 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 7 AF    AFG   Afghanistan  2017 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 8 AF    AFG   Afghanistan  2016 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n 9 AF    AFG   Afghanistan  2015 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n10 AF    AFG   Afghanistan  2014 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16  \n# ℹ 13,887 more rows\n# ℹ 2 more variables: SP.DYN.LE00.IN &lt;dbl&gt;, NY.GDP.PCAP.CD &lt;dbl&gt;\n\n\nMuch better! We now have a data set at the country-year level. Each country-year has information on its average life expectancy and GDP per capita.\nThose variable names are hard to work with and not very meaningful, so we need to clean them up:\n\ngapminder &lt;- rename(gapminder, avg_life_exp = SP.DYN.LE00.IN, gdp_per_cap = NY.GDP.PCAP.CD)\ngapminder\n\n# A tibble: 13,897 × 10\n   iso2c iso3c country  date unit  obs_status footnote last_updated avg_life_exp\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;    &lt;date&gt;              &lt;dbl&gt;\n 1 AF    AFG   Afghan…  2023 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           NA  \n 2 AF    AFG   Afghan…  2022 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           62.9\n 3 AF    AFG   Afghan…  2021 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           62.0\n 4 AF    AFG   Afghan…  2020 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           62.6\n 5 AF    AFG   Afghan…  2019 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           63.6\n 6 AF    AFG   Afghan…  2018 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           63.1\n 7 AF    AFG   Afghan…  2017 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           63.0\n 8 AF    AFG   Afghan…  2016 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           63.1\n 9 AF    AFG   Afghan…  2015 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           62.7\n10 AF    AFG   Afghan…  2014 &lt;NA&gt;  &lt;NA&gt;       &lt;NA&gt;     2024-12-16           62.5\n# ℹ 13,887 more rows\n# ℹ 1 more variable: gdp_per_cap &lt;dbl&gt;\n\n\nThere is also a fair bit of information in this data set that I do not need, so I will remove it and reorder the columns so they are easier to view:\n\ngapminder &lt;- select(gapminder, country, iso3c, date, avg_life_exp, gdp_per_cap)\ngapminder\n\n# A tibble: 13,897 × 5\n   country     iso3c  date avg_life_exp gdp_per_cap\n   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan AFG    2023         NA          416.\n 2 Afghanistan AFG    2022         62.9        357.\n 3 Afghanistan AFG    2021         62.0        356.\n 4 Afghanistan AFG    2020         62.6        511.\n 5 Afghanistan AFG    2019         63.6        497.\n 6 Afghanistan AFG    2018         63.1        491.\n 7 Afghanistan AFG    2017         63.0        525.\n 8 Afghanistan AFG    2016         63.1        522.\n 9 Afghanistan AFG    2015         62.7        566.\n10 Afghanistan AFG    2014         62.5        625.\n# ℹ 13,887 more rows\n\n\nWe now have a nice, clean, and wide data set. You can easily look at the relationship between your two variables of interest over time:\n\ngapminder |&gt; \n  filter(date %in% 2017:2022) |&gt; \n  ggplot(aes(x = log(gdp_per_cap), y = avg_life_exp)) + \n  geom_point() + \n  geom_smooth(method = \"lm\", se = F) + \n  facet_wrap(~ date) + \n  theme_minimal() + \n  labs(x = \"GDP per capita (logged current US$)\",\n       y = \"Average life expectancy\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nfacet_wrap() creates a unique plot for each value in the column you specify. Here, I have used it to create six plots for each of the six years from 2017 to 2022.",
    "crumbs": [
      "Content",
      "Session 3",
      "Data Wrangling"
    ]
  },
  {
    "objectID": "content/03-01-wrangling.html#exercises",
    "href": "content/03-01-wrangling.html#exercises",
    "title": "Data Wrangling",
    "section": "Exercises",
    "text": "Exercises\nName three different types of cases you can use through janitor::clean_names() to format your column names.\n\n\n\n\n\n\nHINT\n\n\n\nRead the argument descriptions in the clean_names() function documentation (by running ?clean_names in your console.\n\n\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\nHere is the full list:\nc(\"snake\", \"small_camel\", \"big_camel\",\n  \"screaming_snake\", \"parsed\", \"mixed\", \"lower_upper\", \"upper_lower\",\n  \"swap\", \"all_caps\", \"lower_camel\", \"upper_camel\", \"internal_parsing\",\n  \"none\", \"flip\", \"sentence\", \"random\", \"title\")\nI like the default (snake case), but other common ones include big camel and all caps.\n\n\n\nHow would you lengthen the gapminder data set we created earlier?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\ngapminder |&gt; \n  pivot_longer(cols = avg_life_exp:gdp_per_cap, names_to = \"indicator\")\n\n# A tibble: 27,794 × 5\n   country     iso3c  date indicator    value\n   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1 Afghanistan AFG    2023 avg_life_exp  NA  \n 2 Afghanistan AFG    2023 gdp_per_cap  416. \n 3 Afghanistan AFG    2022 avg_life_exp  62.9\n 4 Afghanistan AFG    2022 gdp_per_cap  357. \n 5 Afghanistan AFG    2021 avg_life_exp  62.0\n 6 Afghanistan AFG    2021 gdp_per_cap  356. \n 7 Afghanistan AFG    2020 avg_life_exp  62.6\n 8 Afghanistan AFG    2020 gdp_per_cap  511. \n 9 Afghanistan AFG    2019 avg_life_exp  63.6\n10 Afghanistan AFG    2019 gdp_per_cap  497. \n# ℹ 27,784 more rows",
    "crumbs": [
      "Content",
      "Session 3",
      "Data Wrangling"
    ]
  },
  {
    "objectID": "content/01-01-visualization.html",
    "href": "content/01-01-visualization.html",
    "title": "Introducing R Through Data Visualization",
    "section": "",
    "text": "To complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(\"tidyverse\")\n\n\n\n\n\nlibrary(tidyverse)\n\nThis section focuses on introducing you to some new R skills. You will learn how to create your own data visualizations using real-world data.\nTo guide this process, we will use data visualization to answer the following question:\n\nDo cars with big engines use more fuel than cars with small engines?\n\nBefore we get started, answer the following questions:\n\nWhat do you think the answer to this question is?\nHow would you prove your answer? What information about cars would you need?\n\n\n\n\n\n\n\nNote\n\n\n\nI borrow (read: steal) heavily from Hadley Wickham’s R4DSin this and other introductory R sessions. This is a fantastic resource for anyone learning R. I encourage you to use it if you ever get stuck.\n\n\nData visualization is a critical skill for data analysis. You can learn a lot more about your data, including the relationships buried within them, from plots than you can from looking at the raw numbers (and even from complicated statistical models). We will use data visualization throughout this course to learn about our data.\nFor example, we can answer our question above using the following plot:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(colour = class)) + \n  geom_smooth(method = \"lm\") + \n  theme(\n    legend.position = \"bottom\",\n    panel.grid = element_blank(),\n    panel.background = element_blank(),\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\")\n  ) + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  )\n\n\n\n\n\n\n\nWe will now step through how to create this graph using R. During this explanation, you will be introduced to some fundamental elements of R.",
    "crumbs": [
      "Content",
      "Session 1",
      "Introducing R Through Data Visualization"
    ]
  },
  {
    "objectID": "content/01-01-visualization.html#set-up",
    "href": "content/01-01-visualization.html#set-up",
    "title": "Introducing R Through Data Visualization",
    "section": "",
    "text": "To complete this session, you need to load in the following R packages:\n\n\n\n\n\n\nInstall packages\n\n\n\n\n\nTo install new R packages, run the following (excluding the packages you have already installed):\n\ninstall.packages(\"tidyverse\")\n\n\n\n\n\nlibrary(tidyverse)\n\nThis section focuses on introducing you to some new R skills. You will learn how to create your own data visualizations using real-world data.\nTo guide this process, we will use data visualization to answer the following question:\n\nDo cars with big engines use more fuel than cars with small engines?\n\nBefore we get started, answer the following questions:\n\nWhat do you think the answer to this question is?\nHow would you prove your answer? What information about cars would you need?\n\n\n\n\n\n\n\nNote\n\n\n\nI borrow (read: steal) heavily from Hadley Wickham’s R4DSin this and other introductory R sessions. This is a fantastic resource for anyone learning R. I encourage you to use it if you ever get stuck.\n\n\nData visualization is a critical skill for data analysis. You can learn a lot more about your data, including the relationships buried within them, from plots than you can from looking at the raw numbers (and even from complicated statistical models). We will use data visualization throughout this course to learn about our data.\nFor example, we can answer our question above using the following plot:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(colour = class)) + \n  geom_smooth(method = \"lm\") + \n  theme(\n    legend.position = \"bottom\",\n    panel.grid = element_blank(),\n    panel.background = element_blank(),\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\")\n  ) + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  )\n\n\n\n\n\n\n\nWe will now step through how to create this graph using R. During this explanation, you will be introduced to some fundamental elements of R.",
    "crumbs": [
      "Content",
      "Session 1",
      "Introducing R Through Data Visualization"
    ]
  },
  {
    "objectID": "content/01-01-visualization.html#loading-in-and-exploring-your-data",
    "href": "content/01-01-visualization.html#loading-in-and-exploring-your-data",
    "title": "Introducing R Through Data Visualization",
    "section": "Loading in and exploring your data",
    "text": "Loading in and exploring your data\n\n\nFirst, we need to load into our R session the R packages we will use. Today, we will be using the R packages contained within the tidyverse.\n\nlibrary(tidyverse)\n\n\n\n\n\n\n\nTip\n\n\n\nAlways load your packages into your R session at the top of your R script. These scripts run from top to bottom. Loading necessary libraries in at the start ensures you don’t get annoying, missing package errors later on.\n\n\nNext, we need to load in the data we will be using. The mpg data set (which includes lots of information on various car models) comes as part of the ggplot2 R package, which we loaded in with the tidyverse. You can access the data set by running the following:\n\nmpg\n\n# A tibble: 234 × 11\n   manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n 1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n 2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n 3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n 4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n 5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n 6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n 7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n 8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n 9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n# ℹ 224 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe will learn how to load your own data in later in the course.\n\n\nThis data set provides us with information on several different models of cars. Importantly, it includes information on each model’s engine size and average fuel use. We will use the following two variables to answer our question:\n\ndispl: engine displacement, in litres\nhwy: highway miles per gallon\n\n\n\n\n\n\n\nTip\n\n\n\nYou can learn more detail about this data set by running ?mpg from your console.\n\n\nEngine displacement is a useful proxy for a car’s engine size. The larger its displacement, the larger the engine. Similarly, the number of gallons of fuel the car uses on the highway is a useful proxy for its fuel efficiency.\nReturning to our question, do cars with big engines use more fuel than cars with small engines?, what is your hypothesis framed in terms of these two variables?\n\n\n\n\n\n\nHere’s mine:\n\n\n\n\n\nCars with larger engines will travel fewer miles on the highway for each gallon of fuel used than cars with smaller engines.\n\n\n\nExercise\nHow many rows are in mpg? How many columns?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\nThe number of rows and columns are printed at the top of the mpg output. There are 234 rows and 11 columns.\nAlternatively, you can run the following:\n\nnrow(mpg)\n\n[1] 234\n\nncol(mpg)\n\n[1] 11\n\n\n\n\n\nWhat does the drv variable describe?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\nFind the variable description by running the following:\n\n?mpg",
    "crumbs": [
      "Content",
      "Session 1",
      "Introducing R Through Data Visualization"
    ]
  },
  {
    "objectID": "content/01-01-visualization.html#plotting-your-data",
    "href": "content/01-01-visualization.html#plotting-your-data",
    "title": "Introducing R Through Data Visualization",
    "section": "Plotting your data",
    "text": "Plotting your data\n\n\nNext, we need to plot our data. We will use the ggplot2 package to do this. ggplot2 is a wonderfully intuitive and flexible data visualization tool. It is used widely.\nggplot2 works by building up data visualizations in layers. We will start with our blank canvas:\n\nggplot(data = mpg)\n\n\n\n\n\n\n\nHere, we have run the ggplot() function. We have included one argument, data. This is the data frame that includes all the data we want to visualize.\nNext, we need to let ggplot() know which variables we would like to visualize and where we would like them to go. We do this through ggplot()’s mapping argument:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy))\n\n\n\n\n\n\n\nggplot() has now added some structure to our blank canvas. The displ variable is mapped onto the x-axis and the hwy variable is mapped to the y-axis. The mapping argument took a function, aes(), as its value. These are the aesthetics of your plot.\nNext, we need to visualize each data point. We want to produce a scatter plot, so we will add the relevant `ggplot` geometric object to our plot:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point()\n\n\n\n\n\n\n\nAll geometric objects start with geom_. Here are some examples:\n\ngeom_line() plots a line graph\ngeom_col() plots a column graph\ngeom_histogram() plots a histogram.\n\nWe now have a basic plot of our data. We can see a distinct relationship between a car’s engine size and its fuel use: cars with larger engines tend to travel fewer miles on the highway for each gallon of fuel than cars with smaller engines. This supports my hypothesis. Happy days!\nWe can even use ggplot() to visualize this general trend:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nHere, I have used geom_smooth to add a line to my plot that summarizes the relationship between our two variables. I asked it to draw a straight line by setting the argument method to \"lm\" (which stands for linear model).\n\n\n\n\n\n\nNote\n\n\n\nWe will talk a lot more about linear models during this course. Sit tight!\n\n\nAlthough this general trend is interesting, I suspect there are some important differences in this relationship between the different classes of cars. We can quickly check if this is the case by adding a visual cue of those different classes to our plot:\nFirst, I will colour each car’s data point based on its class:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, colour = class)) + \n  geom_point()\n\n\n\n\n\n\n\nNote that I have introduced a new aesthetic to the model: colour. In doing so, I have told ggplot() to vary each data point’s colour based on its class. Each car is classified into one of the following seven classes:\n\n\n# A tibble: 7 × 1\n  class     \n  &lt;chr&gt;     \n1 compact   \n2 midsize   \n3 suv       \n4 2seater   \n5 minivan   \n6 pickup    \n7 subcompact\n\n\n\n\n\n\n\n\nNote\n\n\n\nI, an Australian, am not afraid of my “u”s. Nor, is R! Both American English and “ahem” ~ proper ~ English work in R. For example, you can substitute my colour for color.\n\n\nWe can extend this grouping to all of our layers:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, colour = class)) + \n  geom_point() + \n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nSimiarly, we can isolate which aesthetics apply to which layers by moving the aes() mapping from ggplot() to the specific layer to which we would like to apply it. Remember, ggplot2 is very flexible!\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(aes(colour = class)) + \n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAll aesthetics supplied to the top ggplot() function will be inherited by the layers that proceed it unless you specify otherwise.\n\n\nExercise\nMake a scatter plot of hwy vs cyl.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nggplot(mpg, mapping = aes(x = hwy, y = cyl)) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n\nWhat happens if you make a scatter plot of class vs drv? Why is the plot not useful?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\nScatter plots are best used to visualize the relationship between two continuous variables. These variables have an inherent order to them, allowing us to see how the relationship changes as each grows or shrinks. class and drv are unordered categorical variables, so their order in relation to each other is not meaningful.\n\nggplot(mpg, mapping = aes(x = class, y = drv)) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n\nWhy does the following give an error and how would you fix it?\n\nggplot(data = mpg) + \n  geom_point()\n\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\n\n\n\nAlways read error messages carefully. They often tell you - in plain language - what the problem is and how to fix it. Here, we can see that “geom_point() requires the following missing aesthetics: x and y”. So, to fix it, we need to supply those aesthetics. For example:\n\nggplot(mpg, mapping = aes(x = hwy, y = cyl)) + \n  geom_point()",
    "crumbs": [
      "Content",
      "Session 1",
      "Introducing R Through Data Visualization"
    ]
  },
  {
    "objectID": "content/01-01-visualization.html#styling-your-plot",
    "href": "content/01-01-visualization.html#styling-your-plot",
    "title": "Introducing R Through Data Visualization",
    "section": "Styling your plot",
    "text": "Styling your plot\n\n\nYou have now learnt how to plot your data using ggplot2. However, the default styling leaves a little to be desired. We will now learn how to personalize your plots.\nFirst, we need to add some more information to our plot to make it easier to interpret. We will start with some more useful labels:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(colour = class)) + \n  geom_smooth(method = \"lm\") + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  )\n\n\n\n\n\n\n\nNext, we want to adjust what our plots look like. You can do this to highlight certain elements of your data:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(color = class == \"2seater\")) + \n  geom_smooth(method = \"lm\") + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  )\n\n\n\n\n\n\n\nOr to simply make the graph more appealing to look at:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(colour = \"pink\") + \n  geom_smooth(method = \"lm\") + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  )\n\n\n\n\n\n\n\nLess is often more when it comes to data visualization. Your audience will find it easier to learn about the relationships you want to highlight when your plot is not cluttered with stylistic elements.\nWe can easily strip away a lot of the default ggplot() styling using the theme_minimal() function:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(colour = class)) + \n  geom_smooth(method = \"lm\") + \n  theme_minimal() + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  ) \n\n\n\n\n\n\n\nThere are many preset ggplot2 themes available. You can check them out in the ggplot documentation.\nLike any R function, the ggplot2 theme_X() series of functions are running a more verbose set of R code in the background. You can add in this code directly using the theme() function to control the look of your plot. For example, here are some things I commonly do to my plots:\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(colour = class)) + \n  geom_smooth(method = \"lm\") + \n  theme(\n    legend.position = \"bottom\",\n    panel.grid = element_blank(),\n    panel.background = element_blank(),\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\")\n  ) + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  ) \n\n\n\n\n\n\n\nHere, I have:\n\nMoved the legend to the bottom of the plot\nRemoved the grid lines\nRemoved the grey shading behind the plot\nPulled the plot title closer to the edge of the plot\nMade the plot title bold.\n\nYou can see the many, many different elements of a ggplot2 plot you can control by looking over the theme() function’s documentation:\n\n?theme\n\nExercises\nWhat has gone wrong with this code? Why are the points not blue?\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\nPlacing the color = \"blue\" argument in the aes() means that geom_point() will treat \"blue\" as a variable, not as a value. We need to move it out of aes() and make it a stand-alone argument of geom_point():\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy), color = \"blue\")\n\n\n\n\n\n\n\n\n\n\nName a categorical variable in mpg. Name a continuous one.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\n\nCategorical\n\nmanufacturer\nmodel\ntrans\ndrv\nfl\nclass\n\n\nContinuous\n\ndispl\nyear\ncyl\ncty\nhwy\n\n\n\n\n\n\nMap a continuous variable to color. How does this aesthetics behave differently for categorical vs. continuous variables?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\nggplot() will adapt to create a continuous colour palette for a continuous variable.\n\nggplot(mpg, aes(x = displ, y = hwy, colour = cyl)) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n\nMap class to the shape aesthetic. What does the warning tell you?\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\n\n\n\nThis warning lets us know that ggplot() can plot up to six different unique values under the shape argument. Our data include seven unique values. One (suv) is being dropped out of the visualization.",
    "crumbs": [
      "Content",
      "Session 1",
      "Introducing R Through Data Visualization"
    ]
  },
  {
    "objectID": "content/01-01-visualization.html#working-with-categorical-data",
    "href": "content/01-01-visualization.html#working-with-categorical-data",
    "title": "Introducing R Through Data Visualization",
    "section": "Working with categorical data",
    "text": "Working with categorical data\n\n\nSo far, we have looked at plotting the relationship between two continuous variables. We need different plot types to visualize categorical data.\nFirst, let’s take a look at some categorical variables in our mpg data set:\n\n\n# A tibble: 234 × 3\n   manufacturer model      drv  \n   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;\n 1 audi         a4         f    \n 2 audi         a4         f    \n 3 audi         a4         f    \n 4 audi         a4         f    \n 5 audi         a4         f    \n 6 audi         a4         f    \n 7 audi         a4         f    \n 8 audi         a4 quattro 4    \n 9 audi         a4 quattro 4    \n10 audi         a4 quattro 4    \n# ℹ 224 more rows\n\n\nHere, we have information on each car’s manufacturer, its model name, and its drive train type (front-wheel, rear-wheel, or four-wheel drive).\nWhat is the most popular drive train type among our sample of car models? We can quickly answer this question by visualizing the count of the number of different models in each drive train type:\n\nggplot(mpg, aes(x = drv)) + \n  geom_bar()\n\n\n\n\n\n\n\nIt looks like front-wheel drives (f) are just the most popular type, quickly followed by four-wheel drives. We can reorder our x-axis to follow this ranking:\n\nggplot(mpg, aes(x = fct_infreq(drv))) +\n  geom_bar()\n\n\n\n\n\n\n\nCounts of our data can be very helpful for getting a sense of what is common (or not) among them. For example, I can use a histogram (which plots counts of the number of observations within bins of continuous variables) to see how my variable is distributed across all the range of its values. Here is that distribution for one of our continuous variables above, highway miles per gallon:\n\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram()\n\n\n\n\n\n\n\nFrom this histogram, we learn that the car models in our sample tend to do between roughly 15 to 30 highway miles per gallon of fuel. A small number of cars are more efficient (can do up to over 40 miles with that one gallon). Similarly a small number of cars are very inefficient (only getting around 12 miles with that gallon).\nWe can get a similar, if cleaner, sense of this shape using a density plot:\n\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n\n\n\n\n\n\nThis density plot is showing the same data as the histogram, but it presents a smoother picture. This can often allow us to focus more easily on the shape of the distribution of our data. However, it can gloss over some important details in that distribution. For example, we get less of a sense of the trough (or low point) immediately after 20 miles per gallon in the density plot compared to the histogram.\nWe can also use these data visualizations to easily compare data. For example, here is the distribution of highway miles per gallon for cars according to their drive train type:\n\nggplot(mpg, aes(x = hwy, colour = drv, fill = drv)) +\n  geom_density(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe colour aesthetic controls the thin outline of the density plot. Adding the fill aesthetic makes the groups easier to see. geom_density()’s alpha argument controls the transparency of each density plot.\n\n\nExercise\nPlot the number of observations in each category of a categorical variable in the mpg data set. Make sure to use an appropriate graph type.\n\n\n\n\n\n\nCheck your answer\n\n\n\n\n\n\nggplot(mpg, aes(x = drv)) + \n  geom_bar()",
    "crumbs": [
      "Content",
      "Session 1",
      "Introducing R Through Data Visualization"
    ]
  },
  {
    "objectID": "content/slides/01-02-load_data.html#data-visualisation",
    "href": "content/slides/01-02-load_data.html#data-visualisation",
    "title": "Loading and Exploring Your Data",
    "section": "Data visualisation",
    "text": "Data visualisation\nWe will use data visualization to answer the following question:\n\nDo cars with big engines use more fuel than cars with small engines?"
  },
  {
    "objectID": "content/slides/01-02-load_data.html#load-relevant-packages",
    "href": "content/slides/01-02-load_data.html#load-relevant-packages",
    "title": "Loading and Exploring Your Data",
    "section": "Load relevant packages",
    "text": "Load relevant packages\n\n# Load relevant packages\nlibrary(tidyverse)"
  },
  {
    "objectID": "content/slides/01-02-load_data.html#load-in-relevant-data",
    "href": "content/slides/01-02-load_data.html#load-in-relevant-data",
    "title": "Loading and Exploring Your Data",
    "section": "Load in relevant data",
    "text": "Load in relevant data\n\n# Load the data\nmpg\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\n\n\n\n\naudi\na4\n1.8\n1999\n4\n\n\naudi\na4\n1.8\n1999\n4\n\n\naudi\na4\n2.0\n2008\n4\n\n\naudi\na4\n2.0\n2008\n4\n\n\naudi\na4\n2.8\n1999\n6\n\n\naudi\na4\n2.8\n1999\n6"
  },
  {
    "objectID": "content/slides/01-02-load_data.html#the-mpg-data-set",
    "href": "content/slides/01-02-load_data.html#the-mpg-data-set",
    "title": "Loading and Exploring Your Data",
    "section": "The mpg data set",
    "text": "The mpg data set\nA couple of useful variables:\n\ndispl: engine displacement, in liters\nhwy: highway miles per gallon"
  },
  {
    "objectID": "content/slides/01-03-plot.html#data-visualization",
    "href": "content/slides/01-03-plot.html#data-visualization",
    "title": "Plotting Your Data",
    "section": "Data visualization",
    "text": "Data visualization\nWe will use data visualization to answer the following question:\n\nDo cars with big engines use more fuel than cars with small engines?"
  },
  {
    "objectID": "content/slides/01-03-plot.html#set-up-your-plot",
    "href": "content/slides/01-03-plot.html#set-up-your-plot",
    "title": "Plotting Your Data",
    "section": "Set up your plot",
    "text": "Set up your plot\nAn empty canvas!\n\nggplot(data = mpg)"
  },
  {
    "objectID": "content/slides/01-03-plot.html#map-your-aesthetics",
    "href": "content/slides/01-03-plot.html#map-your-aesthetics",
    "title": "Plotting Your Data",
    "section": "Map your aesthetics",
    "text": "Map your aesthetics\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy))"
  },
  {
    "objectID": "content/slides/01-03-plot.html#add-in-your-cars",
    "href": "content/slides/01-03-plot.html#add-in-your-cars",
    "title": "Plotting Your Data",
    "section": "Add in your cars",
    "text": "Add in your cars\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point()"
  },
  {
    "objectID": "content/slides/01-03-plot.html#look-at-the-relationship-across-all-cars",
    "href": "content/slides/01-03-plot.html#look-at-the-relationship-across-all-cars",
    "title": "Plotting Your Data",
    "section": "Look at the relationship across all cars",
    "text": "Look at the relationship across all cars\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth(method = \"lm\")"
  },
  {
    "objectID": "content/slides/01-03-plot.html#lets-look-at-groups-in-the-data",
    "href": "content/slides/01-03-plot.html#lets-look-at-groups-in-the-data",
    "title": "Plotting Your Data",
    "section": "Let’s look at groups in the data",
    "text": "Let’s look at groups in the data\n\nCan look at more than two interesting elements of our data.\nYou can use visual elements or aesthetics (aes) to communicate many dimensions in your data.\nLet’s look at a categorical variable: the class of car (SUV, 2 seater, pick up truck, etc.).\nLook for meaningfully defined groups."
  },
  {
    "objectID": "content/slides/01-03-plot.html#lets-look-at-groups-in-the-data-1",
    "href": "content/slides/01-03-plot.html#lets-look-at-groups-in-the-data-1",
    "title": "Plotting Your Data",
    "section": "Let’s look at groups in the data",
    "text": "Let’s look at groups in the data\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, colour = class)) + \n  geom_point()"
  },
  {
    "objectID": "content/slides/01-03-plot.html#look-at-the-relationship-within-groups",
    "href": "content/slides/01-03-plot.html#look-at-the-relationship-within-groups",
    "title": "Plotting Your Data",
    "section": "Look at the relationship within groups",
    "text": "Look at the relationship within groups\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, colour = class)) + \n  geom_point() + \n  geom_smooth(method = \"lm\")"
  },
  {
    "objectID": "content/slides/01-03-plot.html#aesthetics-can-be-isolated",
    "href": "content/slides/01-03-plot.html#aesthetics-can-be-isolated",
    "title": "Plotting Your Data",
    "section": "Aesthetics can be isolated",
    "text": "Aesthetics can be isolated\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(aes(colour = class)) + \n  geom_smooth(method = \"lm\")"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#data-visualization",
    "href": "content/slides/01-05-personal_plots.html#data-visualization",
    "title": "Styling Your Plots",
    "section": "Data visualization",
    "text": "Data visualization\nWe will use data visualization to answer the following question:\n\nDo cars with big engines use more fuel than cars with small engines?"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#add-useful-titles-and-labels",
    "href": "content/slides/01-05-personal_plots.html#add-useful-titles-and-labels",
    "title": "Styling Your Plots",
    "section": "Add useful titles and labels",
    "text": "Add useful titles and labels\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(colour = class)) + \n  geom_smooth(method = \"lm\") + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  )"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#add-useful-titles-and-labels-1",
    "href": "content/slides/01-05-personal_plots.html#add-useful-titles-and-labels-1",
    "title": "Styling Your Plots",
    "section": "Add useful titles and labels",
    "text": "Add useful titles and labels"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#flexible-visualization",
    "href": "content/slides/01-05-personal_plots.html#flexible-visualization",
    "title": "Styling Your Plots",
    "section": "Flexible visualization",
    "text": "Flexible visualization\nYou can use visual elements to communicate your findings in engaging ways.\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(color = class == \"2seater\")) + \n  geom_smooth(method = \"lm\") + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  )"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#changing-the-look-of-your-plots",
    "href": "content/slides/01-05-personal_plots.html#changing-the-look-of-your-plots",
    "title": "Styling Your Plots",
    "section": "Changing the look of your plots",
    "text": "Changing the look of your plots\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(colour = \"pink\") + \n  geom_smooth(method = \"lm\") + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  )"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#lets-clean-our-graph-up",
    "href": "content/slides/01-05-personal_plots.html#lets-clean-our-graph-up",
    "title": "Styling Your Plots",
    "section": "Let’s clean our graph up",
    "text": "Let’s clean our graph up\nLess is more when it comes to data visualization.\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(colour = class)) + \n  geom_smooth(method = \"lm\") + \n  theme_minimal() + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  ) \n\n\n\nAll pre-set ggplot themes can be found in the ggplot documentation."
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#lets-clean-this-up",
    "href": "content/slides/01-05-personal_plots.html#lets-clean-this-up",
    "title": "Styling Your Plots",
    "section": "Let’s clean this up",
    "text": "Let’s clean this up"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#creating-your-own-theme",
    "href": "content/slides/01-05-personal_plots.html#creating-your-own-theme",
    "title": "Styling Your Plots",
    "section": "Creating your own theme",
    "text": "Creating your own theme\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(colour = class)) + \n  geom_smooth(method = \"lm\") + \n  theme(\n    legend.position = \"bottom\",\n    panel.grid = element_blank(),\n    panel.background = element_blank(),\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\")\n  ) + \n  labs(\n    title = \"Engine displacement and highway miles per gallon\",\n    subtitle = \"Values for seven different classes of cars\",\n    x = \"Engine displacement (L)\",\n    y = \"Highway miles per gallon\"\n  ) \n\n\n\nAll theme elements that you can control can be found in the ggplot documentation. There are a lot!"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#creating-your-own-theme-1",
    "href": "content/slides/01-05-personal_plots.html#creating-your-own-theme-1",
    "title": "Styling Your Plots",
    "section": "Creating your own theme",
    "text": "Creating your own theme"
  },
  {
    "objectID": "content/slides/01-05-personal_plots.html#the-before-shot",
    "href": "content/slides/01-05-personal_plots.html#the-before-shot",
    "title": "Styling Your Plots",
    "section": "The before shot",
    "text": "The before shot"
  }
]